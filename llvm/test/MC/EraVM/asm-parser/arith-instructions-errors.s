; RUN: not llvm-mc -triple eravm -o - < %s 2>&1 > %t.stdout | FileCheck %s
; RUN: FileCheck --check-prefix=STDOUT %s < %t.stdout

; STDOUT:     .text
; STDOUT-NOT: {{.+}}

; operands (2nd input should be register)
  add       r1, 42, r3
  add       r1, stack[r2 + 1], r3
  ; FIXME add       r1, stack-[r2 + 1], r3
  add       r1, code[r2 + 1], r3

; operands (output should be writable)
  add       r1, r2, 42
  add       r1, r2, code[r3 + 1]

; operands (2nd output dhould be register, if any)
  mul r1, r2, r3, stack[r4 + 1]

; correct number of outputs
  add r1, r2, r3, r4
  ; FIXME mul r1, r2, r3


; COM: Autogenerated checks below, see README.md.
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    add       r1, 42, r3
; CHECK-NEXT:    ^
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    add       r1, stack[r2 + 1], r3
; CHECK-NEXT:    ^
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    add       r1, code[r2 + 1], r3
; CHECK-NEXT:    ^
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    add       r1, r2, 42
; CHECK-NEXT:    ^
; CHECK:       <stdin>:{{[0-9]+}}:21: error: cannot parse operand
; CHECK-NEXT:    add       r1, r2, code[r3 + 1]
; CHECK-NEXT:                      ^
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    mul r1, r2, r3, stack[r4 + 1]
; CHECK-NEXT:    ^
; CHECK:       <stdin>:{{[0-9]+}}:3: error: cannot parse instruction
; CHECK-NEXT:    add r1, r2, r3, r4
; CHECK-NEXT:    ^
