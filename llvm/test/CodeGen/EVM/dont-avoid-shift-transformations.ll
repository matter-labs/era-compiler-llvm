; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -O3 < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S256-a:256:256"
target triple = "evm"

; Check the following conversion in TargetLowering::SimplifySetCC
; (X & 8) != 0  -->  (X & 8) >> 3
define i256 @test1(i256 %x) {
; CHECK-LABEL: test1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0x20
; CHECK-NEXT:    AND
; CHECK-NEXT:    PUSH1 0x5
; CHECK-NEXT:    SHR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %and = and i256 %x, 32
  %cmp = icmp ne i256 %and, 0
  %conv = zext i1 %cmp to i256
  ret i256 %conv
}

; Check the following conversion in TargetLowering::SimplifySetCC
; (X & 8) == 8  -->  (X & 8) >> 3
define i256 @test2(i256 %x) {
; CHECK-LABEL: test2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0x20
; CHECK-NEXT:    AND
; CHECK-NEXT:    PUSH1 0x5
; CHECK-NEXT:    SHR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %and = and i256 %x, 32
  %cmp = icmp eq i256 %and, 32
  %conv = zext i1 %cmp to i256
  ret i256 %conv
}

; Check the following conversion in DAGCombiner::SimplifySelectCC
; (select_cc seteq (and x, y), 0, 0, A) -> (and (shr (shl x)) A)
define i256 @test3(i256 %x, i256 %a) {
; CHECK-LABEL: test3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0xF4
; CHECK-NEXT:    SHL
; CHECK-NEXT:    PUSH1 0xFF
; CHECK-NEXT:    SAR
; CHECK-NEXT:    AND
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %and = and i256 %x, 2048
  %cmp = icmp eq i256 %and, 0
  %cond = select i1 %cmp, i256 0, i256 %a
  ret i256 %cond
}

; Check the following conversion in DAGCombiner foldExtendedSignBitTest
; sext i1 (setgt iN X, -1) --> sra (not X), (N - 1)
define i256 @test4(i256 %x) {
; CHECK-LABEL: test4:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    NOT
; CHECK-NEXT:    PUSH1 0xFF
; CHECK-NEXT:    SAR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %cmp = icmp sgt i256 %x, -1
  %cond = sext i1 %cmp to i256
  ret i256 %cond
}

; Check the following conversion in DAGCombiner foldExtendedSignBitTest
; zext i1 (setgt iN X, -1) --> srl (not X), (N - 1)
define i256 @test5(i256 %x) {
; CHECK-LABEL: test5:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    NOT
; CHECK-NEXT:    PUSH1 0xFF
; CHECK-NEXT:    SHR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %cmp = icmp sgt i256 %x, -1
  %cond = zext i1 %cmp to i256
  ret i256 %cond
}

; Check the following conversion in DAGCombiner::foldSelectCCToShiftAnd
; select_cc setlt X, 0, A, 0 -> and (sra X, size(X)-1), A
define i256 @test6(i256 %x, i256 %a) {
; CHECK-LABEL: test6:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0xFF
; CHECK-NEXT:    SAR
; CHECK-NEXT:    AND
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %cmp = icmp slt i256 %x, 0
  %cond = select i1 %cmp, i256 %a, i256 0
  ret i256 %cond
}

; Check the following conversion in DAGCombiner::foldSelectCCToShiftAnd
; select_cc setlt X, 0, A, 0 -> "and (srl X, C2), A" iff A is a single-bit
define i256 @test7(i256 %x) {
; CHECK-LABEL: test7:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0x2
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    PUSH1 0xFE
; CHECK-NEXT:    SHR
; CHECK-NEXT:    AND
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %cmp = icmp slt i256 %x, 0
  %cond = select i1 %cmp, i256 2, i256 0
  ret i256 %cond
}

; Check the following conversion in DAGCombiner::SimplifySelectCC
; select C, 16, 0 -> shl C, 4
define i256 @test8(i256 %a, i256 %b) {
; CHECK-LABEL: test8:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SGT
; CHECK-NEXT:    PUSH1 0x5
; CHECK-NEXT:    SHL
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
entry:
  %cmp = icmp sgt i256 %a, %b
  %cond = select i1 %cmp, i256 32, i256 0
  ret i256 %cond
}
