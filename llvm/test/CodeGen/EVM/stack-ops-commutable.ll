; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S256-a:256:256"
target triple = "evm"

define void @no_manipulations_needed_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: no_manipulations_needed_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a1, %a2
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  unreachable
}

define void @no_manipulations_needed_with_junk_eq(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: no_manipulations_needed_with_junk_eq:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    EQ
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %cmp = icmp eq i256 %a1, %a2
  %x1 = zext i1 %cmp to i256
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  unreachable

}

define i256 @no_manipulations_needed_no_junk_addmod(i256 %a1, i256 %a2, i256 %a3) {
; CHECK-LABEL: no_manipulations_needed_no_junk_addmod:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    ADDMOD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = call i256 @llvm.evm.addmod(i256 %a2, i256 %a1, i256 %a3)
  ret i256 %x1
}

define i256 @no_manipulations_needed_no_junk_mulmod(i256 %a1, i256 %a2, i256 %a3) {
; CHECK-LABEL: no_manipulations_needed_no_junk_mulmod:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    MULMOD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = call i256 @llvm.evm.mulmod(i256 %a2, i256 %a1, i256 %a3)
  ret i256 %x1
}

define i256 @no_manipulations_needed_no_junk_and(i256 %a1, i256 %a2) {
; CHECK-LABEL: no_manipulations_needed_no_junk_and:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    AND
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = and i256 %a2, %a1
  ret i256 %x1
}

define i256 @no_manipulations_needed_no_junk_or(i256 %a1, i256 %a2) {
; CHECK-LABEL: no_manipulations_needed_no_junk_or:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    OR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = or i256 %a2, %a1
  ret i256 %x1
}

define i256 @no_manipulations_needed_no_junk_xor(i256 %a1, i256 %a2) {
; CHECK-LABEL: no_manipulations_needed_no_junk_xor:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    XOR
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = xor i256 %a2, %a1
  ret i256 %x1
}

define i256 @no_manipulations_needed_no_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: no_manipulations_needed_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a1, %a2
  ret i256 %x1
}

define void @reorder_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: reorder_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a2, %a1
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  unreachable
}

define i256 @reorder_no_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: reorder_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a2, %a1
  ret i256 %x1
}

define void @swap_first_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: swap_first_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a3, %a2
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  unreachable
}

define i256 @two_commutable(i256 %a1, i256 %a2, i256 %a3) {
; CHECK-LABEL: two_commutable:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    ADD
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a3, %a2
  %x2 = add i256 %a1, %x1
  ret i256 %x2
}

define void @swap_second_with_junk(i256 %a1, i256 %a2, i256 %a3, i256 %a4) noreturn {
; CHECK-LABEL: swap_second_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a1, %a4
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  unreachable
}

define i256 @swap_first_no_junk(i256 %a1, i256 %a2, i256 %a3, i256 %a4) nounwind {
; CHECK-LABEL: swap_first_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a1, %a4
  ret i256 %x1
}

define i256 @swap_second_no_junk(i256 %a1, i256 %a2, i256 %a3, i256 %a4) nounwind {
; CHECK-LABEL: swap_second_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a4, %a1
  ret i256 %x1
}

define void @first_arg_alive_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: first_arg_alive_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP1
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    POP
; CHECK-NEXT:    PUSH1 0x4
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    SUB
; CHECK-NEXT:    DIV
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a1, %a2
  %x2 = sub i256 %a1, 4
  %x3 = udiv i256 %x2, %x1
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x3)
  unreachable
}

define i256 @first_arg_alive_no_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: first_arg_alive_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP1
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    POP
; CHECK-NEXT:    PUSH1 0x4
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    SUB
; CHECK-NEXT:    DIV
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a1, %a2
  %x2 = sub i256 %a1, 4
  %x3 = udiv i256 %x2, %x1
  ret i256 %x3
}

define void @second_arg_alive_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: second_arg_alive_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    PUSH1 0x4
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    SWAP4
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    SUB
; CHECK-NEXT:    DIV
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a1, %a2
  %x2 = sub i256 %a2, 4
  %x3 = udiv i256 %x2, %x1
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x3)
  unreachable
}

define i256 @second_arg_alive_no_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: second_arg_alive_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    PUSH1 0x4
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    SWAP4
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    SUB
; CHECK-NEXT:    DIV
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a1, %a2
  %x2 = sub i256 %a2, 4
  %x3 = udiv i256 %x2, %x1
  ret i256 %x3
}

define void @both_arg_alive_with_junk(i256 %a1, i256 %a2, i256 %a3) noreturn {
; CHECK-LABEL: both_arg_alive_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP1
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    POP
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    DIV
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    ADD
; CHECK-NEXT:    ADD
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
  %x1 = add i256 %a1, %a2
  %x2 = udiv i256 %a2, %a1
  %x3 = add i256 %x1, %x2
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x3)
  unreachable
}

define i256 @both_arg_alive_no_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: both_arg_alive_no_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    DUP1
; CHECK-NEXT:    SWAP3
; CHECK-NEXT:    POP
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    DIV
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    ADD
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a1, %a2
  %x2 = udiv i256 %a2, %a1
  %x3 = add i256 %x1, %x2
  ret i256 %x3
}

define i256 @same_arg_dead_with_junk(i256 %a1, i256 %a2, i256 %a3) nounwind {
; CHECK-LABEL: same_arg_dead_with_junk:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    POP
; CHECK-NEXT:    DUP1
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    ADD
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    REVERT
; CHECK-NEXT:    JUMP
  %x1 = add i256 %a2, %a2
  call void @llvm.evm.revert(ptr addrspace(1) null, i256 %x1)
  ret i256 %x1
}

define void @commutable_not_in_function_entry() noreturn {
; CHECK-LABEL: commutable_not_in_function_entry:
; CHECK:       ; %bb.0: ; %enter
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    CALLDATALOAD
; CHECK-NEXT:    PUSH1 0x1
; CHECK-NEXT:  .BB22_1: ; %header
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH1 0x1
; CHECK-NEXT:    DUP3
; CHECK-NEXT:    PUSH1 0x3
; CHECK-NEXT:    SIGNEXTEND
; CHECK-NEXT:    SLT
; CHECK-NEXT:    PUSH4 @.BB22_3
; CHECK-NEXT:    JUMPI
; CHECK-NEXT:  ; %bb.2: ; %do
; CHECK-NEXT:    ; in Loop: Header=BB22_1 Depth=1
; CHECK-NEXT:    DUP2
; CHECK-NEXT:    PUSH1 0x1
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    MUL
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    SUB
; CHECK-NEXT:    SWAP1
; CHECK-NEXT:    PUSH4 @.BB22_1
; CHECK-NEXT:    JUMP
; CHECK-NEXT:  .BB22_3: ; %exit
; CHECK-NEXT:    JUMPDEST
; CHECK-NEXT:    PUSH4 0xFFFFFFFF
; CHECK-NEXT:    SWAP2
; CHECK-NEXT:    POP
; CHECK-NEXT:    AND
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    MSTORE
; CHECK-NEXT:    PUSH1 0x20
; CHECK-NEXT:    PUSH0
; CHECK-NEXT:    RETURN

enter:
  %offset = inttoptr i256 0 to ptr addrspace(2)
  %load = call i256 @llvm.evm.calldataload(ptr addrspace(2) %offset)
  %calldata = trunc i256 %load to i32
  br label %header

header:
  %phi = phi i32 [ %calldata, %enter ], [ %inc, %do ]
  %phi2 = phi i32 [ 1, %enter ], [ %mul, %do ]
  %cmp = icmp sgt i32 %phi, 0
  br i1 %cmp, label %do, label %exit

do:
  %mul = mul nsw i32 %phi2, %phi
  %inc = add nsw i32 %phi, -1
  br label %header

exit:
  %res = zext i32 %phi2 to i256
  store i256 %res, ptr addrspace(1) null, align 4
  call void @llvm.evm.return(ptr addrspace(1) null, i256 32)
  unreachable
}

declare i256 @llvm.evm.addmod(i256, i256, i256)
declare i256 @llvm.evm.mulmod(i256, i256, i256)
declare i256 @llvm.evm.calldataload(ptr addrspace(2))
declare void @llvm.evm.return(ptr addrspace(1), i256)
declare void @llvm.evm.revert(ptr addrspace(1), i256)
