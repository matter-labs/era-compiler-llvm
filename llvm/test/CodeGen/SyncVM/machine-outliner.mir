# RUN: llc -x mir -run-pass=machine-outliner -verify-machineinstrs < %s | FileCheck %s

--- |

  define void @foo(i256 %a, i256 %b) { ret void }
  define void @bar(i256 %a, i256 %b) { ret void }
  define void @baz(i256 %a, i256 %b) { ret void }

...
---
# This test ensures that we
# - Create outlined functions
# - Don't outline candidates where Flags register is defined outside, but used in a sequence
#
# CHECK-LABEL: foo
# CHECK-LABEL: bb.0:
# CHECK: $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
# CHECK-NEXT: NEAR_CALL $r0, @OUTLINED_FUNCTION_[[F0:[0-9]+]], &DEFAULT_UNWIND

# CHECK-LABEL: bb.1:
# CHECK: $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
# CHECK-NEXT: NEAR_CALL $r0, @OUTLINED_FUNCTION_[[F0:[0-9]+]], &DEFAULT_UNWIND

# CHECK-LABEL: bb.2:
# CHECK: NEAR_CALL $r0, @OUTLINED_FUNCTION_[[F0:[0-9]+]], &DEFAULT_UNWIND
# CHECK-NEXT: RET
name:            foo
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r1, $r2
    $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
  bb.1:
    liveins: $r1, $r2
    $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
  bb.2:
    liveins: $r1, $r2
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    RET

...
---
# This test ensures that we
# - Can't create outlined functions becuase Flags register is defined in a sequence, but used outside
#
# CHECK-LABEL: bar
# CHECK-LABEL: bb.0:
# CHECK: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags

# CHECK-LABEL: bb.1:
# CHECK: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
# CHECK-NEXT: $r1 = ORrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
# CHECK-NEXT: RET
name:            bar
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r1, $r2
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
  bb.1:
    liveins: $r1, $r2
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
    $r1 = ORrrr_s $r1, $r2, 0
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
    RET

...
---
# This test ensures that we
# - Can't create outlined functions becuase Flags are propagated across MBBs
#
# CHECK-LABEL: baz
# CHECK-LABEL: bb.0:
# CHECK: $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
# CHECK-NEXT: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0

# CHECK-LABEL: bb.1:
# CHECK: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0

# CHECK-LABEL: bb.2:
# CHECK: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0
# CHECK-NEXT: $r1 = ANDrrr_s $r1, $r2, 0

# CHECK-LABEL: bb.3:
# CHECK: $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
# CHECK-NEXT: RET
name:            baz
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r1, $r2
    $r1 = ANDrrr_v $r1, $r2, 0, implicit-def $flags
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
  bb.1:
    liveins: $r1, $r2
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
  bb.2:
    liveins: $r1, $r2
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
    $r1 = ANDrrr_s $r1, $r2, 0
  bb.3:
    $r1 = ADDirr_s i256 1, $r0, 2, implicit $flags
    RET
