; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=eravm-post-codegen-prepare -S < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

@glob = internal unnamed_addr global ptr addrspace(3) null
@glob1 = internal unnamed_addr global ptr addrspace(3) null

declare void @foo()
declare void @foo_readonly() readonly

define i256 @test1(ptr addrspace(3) %ptr1) {
; CHECK-LABEL: define i256 @test1
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test2(ptr addrspace(3) %ptr1) {
; CHECK-LABEL: define i256 @test2
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    call void @foo_readonly()
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  call void @foo_readonly()
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test3(ptr addrspace(3) %ptr1, ptr addrspace(3) %ptr2) {
; CHECK-LABEL: define i256 @test3
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]], ptr addrspace(3) [[PTR2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR2]], ptr @glob1, align 32
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  store ptr addrspace(3) %ptr2, ptr @glob1, align 32
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test4(ptr addrspace(3) %ptr1, ptr addrspace(3) %ptr2) {
; CHECK-LABEL: define i256 @test4
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]], ptr addrspace(3) [[PTR2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    store ptr addrspace(3) [[PTR2]], ptr @glob, align 32
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  store ptr addrspace(3) %ptr2, ptr @glob, align 32
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test_not1(ptr addrspace(3) %ptr1, ptr addrspace(3) %ptr2) {
; CHECK-LABEL: define i256 @test_not1
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]], ptr addrspace(3) [[PTR2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR2]], ptr @glob, align 32
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  store ptr addrspace(3) %ptr2, ptr @glob, align 32
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test_not2(ptr addrspace(3) %ptr1, ptr addrspace(3) %ptr2) {
; CHECK-LABEL: define i256 @test_not2
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]], ptr addrspace(3) [[PTR2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    store ptr addrspace(3) [[PTR2]], ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  store ptr addrspace(3) %ptr2, ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test_not3(ptr addrspace(3) %ptr1, ptr addrspace(3) %ptr2) {
; CHECK-LABEL: define i256 @test_not3
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]], ptr addrspace(3) [[PTR2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY_INC:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY_INC]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY:%.*]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i256 [[I]], 10
; CHECK-NEXT:    br i1 [[CMP1]], label [[LOOP_BODY_THEN:%.*]], label [[LOOP_BODY_INC]]
; CHECK:       loop_body_then:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR2]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_BODY_INC]]
; CHECK:       loop_body_inc:
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body_inc ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body_inc ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  %cmp1 = icmp eq i256 %i, 10
  br i1 %cmp1, label %loop_body_then, label %loop_body_inc

loop_body_then:
  store ptr addrspace(3) %ptr2, ptr @glob, align 32
  br label %loop_body_inc

loop_body_inc:
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

define i256 @test_not4(ptr addrspace(3) %ptr1) {
; CHECK-LABEL: define i256 @test_not4
; CHECK-SAME: (ptr addrspace(3) [[PTR1:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store ptr addrspace(3) [[PTR1]], ptr @glob, align 32
; CHECK-NEXT:    br label [[LOOP_HEADER:%.*]]
; CHECK:       loop_header:
; CHECK-NEXT:    [[I:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[LOOP_BODY_INC:%.*]] ]
; CHECK-NEXT:    [[RESULT:%.*]] = phi i256 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP_BODY_INC]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load ptr addrspace(3), ptr @glob, align 32
; CHECK-NEXT:    [[ADDP1:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 [[I]])
; CHECK-NEXT:    [[LOAD2:%.*]] = load i256, ptr addrspace(3) [[ADDP1]], align 32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i256 [[LOAD2]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP_BODY:%.*]], label [[EXIT:%.*]]
; CHECK:       loop_body:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i256 [[I]], 10
; CHECK-NEXT:    br i1 [[CMP1]], label [[LOOP_BODY_THEN:%.*]], label [[LOOP_BODY_INC]]
; CHECK:       loop_body_then:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    br label [[LOOP_BODY_INC]]
; CHECK:       loop_body_inc:
; CHECK-NEXT:    [[ADDP2:%.*]] = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) [[LOAD1]], i256 1)
; CHECK-NEXT:    [[LOAD3:%.*]] = load i256, ptr addrspace(3) [[ADDP2]], align 32
; CHECK-NEXT:    [[ADD]] = add nuw nsw i256 [[RESULT]], [[LOAD3]]
; CHECK-NEXT:    [[INC]] = add i256 [[I]], 1
; CHECK-NEXT:    br label [[LOOP_HEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret i256 [[RESULT]]
;
entry:
  store ptr addrspace(3) %ptr1, ptr @glob, align 32
  br label %loop_header

loop_header:
  %i = phi i256 [ 0, %entry ], [ %inc, %loop_body_inc ]
  %result = phi i256 [ 0, %entry ], [ %add, %loop_body_inc ]
  %load1 = load ptr addrspace(3), ptr @glob, align 32
  %addp1 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 %i)
  %load2 = load i256, ptr addrspace(3) %addp1, align 32
  %cmp = icmp ult i256 %load2, 10
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  %cmp1 = icmp eq i256 %i, 10
  br i1 %cmp1, label %loop_body_then, label %loop_body_inc

loop_body_then:
  call void @foo()
  br label %loop_body_inc

loop_body_inc:
  %addp2 = call ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3) %load1, i256 1)
  %load3 = load i256, ptr addrspace(3) %addp2, align 32
  %add = add nuw nsw i256 %result, %load3
  %inc = add i256 %i, 1
  br label %loop_header

exit:
  ret i256 %result
}

declare ptr addrspace(3) @llvm.eravm.ptr.add(ptr addrspace(3), i256)
