; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -O3 --disable-eravm-scalar-opt-passes < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

declare { i256, i1 } @llvm.uadd.with.overflow.i256(i256, i256)
declare { i256, i1 } @llvm.usub.with.overflow.i256(i256, i256)
declare { i256, i1 } @llvm.umul.with.overflow.i256(i256, i256)
declare void @has_overflow()
declare void @has_no_overflow()

define void @uaddo_branch_1(i256 %x, i256 %y) {
; CHECK-LABEL: uaddo_branch_1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    add! r1, r2, r0
; CHECK-NEXT:    jump.lt @.BB0_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB0_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.uadd.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret void
}

define void @uadd_branch_2(i256 %x, i256 %y) {
; CHECK-LABEL: uadd_branch_2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    add! r1, r2, r0
; CHECK-NEXT:    jump.lt @.BB1_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB1_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.uadd.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

overflow_detected:
  call void @has_overflow()
  br label %exit

exit:
  ret void
}

define i256 @uadd_branch_3(i256 %x, i256 %y) {
; CHECK-LABEL: uadd_branch_3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1 + r0]
; CHECK-NEXT:    add r1, r2, stack-[1]
; CHECK-NEXT:    add! r1, r2, r0
; CHECK-NEXT:    jump.lt @.BB2_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB2_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.uadd.with.overflow.i256(i256 %x, i256 %y)
  %sum = extractvalue {i256, i1} %res1, 0
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret i256 %sum
}

define i256 @uadd_branch_complicated(i256 %a, i256 %b, i256 %c, i256 %x, i256 %y) {
; CHECK-LABEL: uadd_branch_complicated:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1 + r0]
; CHECK-NEXT:    add r4, r5, r6
; CHECK-NEXT:    sub! r1, r2, r0
; CHECK-NEXT:    add.lt r3, r0, r6
; CHECK-NEXT:    add r6, r0, stack-[1] ; 32-byte Folded Spill
; CHECK-NEXT:    add! r4, r5, r0
; CHECK-NEXT:    jump.lt @.BB3_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB3_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.uadd.with.overflow.i256(i256 %x, i256 %y)
  %sum = extractvalue {i256, i1} %res1, 0
  %cmp = icmp uge i256 %a, %b
  %val = select i1 %cmp, i256 %sum, i256 %c
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

overflow_detected:
  call void @has_overflow()
  br label %exit

exit:
  ret i256 %val
}

define void @usub_branch_1(i256 %x, i256 %y) {
; CHECK-LABEL: usub_branch_1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r2, r0
; CHECK-NEXT:    jump.lt @.BB4_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB4_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.usub.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret void
}

define void @usub_branch_2(i256 %x, i256 %y) {
; CHECK-LABEL: usub_branch_2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r2, r0
; CHECK-NEXT:    jump.lt @.BB5_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB5_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.usub.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

overflow_detected:
  call void @has_overflow()
  br label %exit

exit:
  ret void
}

define i256 @usub_branch_3(i256 %x, i256 %y) {
; CHECK-LABEL: usub_branch_3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1 + r0]
; CHECK-NEXT:    sub! r1, r2, stack-[1]
; CHECK-NEXT:    jump.lt @.BB6_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB6_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.usub.with.overflow.i256(i256 %x, i256 %y)
  %sum = extractvalue {i256, i1} %res1, 0
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret i256 %sum
}

define void @umul_branch_1(i256 %x, i256 %y) {
; CHECK-LABEL: umul_branch_1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mul! r1, r2, r0, r0
; CHECK-NEXT:    jump.lt @.BB7_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB7_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.umul.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret void
}

define void @umul_branch_2(i256 %x, i256 %y) {
; CHECK-LABEL: umul_branch_2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mul! r1, r2, r0, r0
; CHECK-NEXT:    jump.lt @.BB8_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB8_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.umul.with.overflow.i256(i256 %x, i256 %y)
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

overflow_detected:
  call void @has_overflow()
  br label %exit

exit:
  ret void
}

define i256 @umul_branch_3(i256 %x, i256 %y) {
; CHECK-LABEL: umul_branch_3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1 + r0]
; CHECK-NEXT:    mul r1, r2, stack-[1], r0
; CHECK-NEXT:    mul! r1, r2, r0, r0
; CHECK-NEXT:    jump.lt @.BB9_2
; CHECK-NEXT:  ; %bb.1: ; %no_overflow_detected
; CHECK-NEXT:    near_call r0, @has_no_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB9_2: ; %overflow_detected
; CHECK-NEXT:    near_call r0, @has_overflow, @DEFAULT_UNWIND
; CHECK-NEXT:    add stack-[1], r0, r1 ; 32-byte Folded Reload
; CHECK-NEXT:    ret
entry:
  %res1 = call {i256, i1} @llvm.umul.with.overflow.i256(i256 %x, i256 %y)
  %sum = extractvalue {i256, i1} %res1, 0
  %overflow = extractvalue {i256, i1} %res1, 1
  br i1 %overflow, label %overflow_detected, label %no_overflow_detected

overflow_detected:
  call void @has_overflow()
  br label %exit

no_overflow_detected:
  call void @has_no_overflow()
  br label %exit

exit:
  ret i256 %sum
}
