; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=eravm-lower-intrinsics -S < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

declare void @llvm.memmove.p1.p1.i256(ptr addrspace(1), ptr addrspace(1), i256, i1 immarg)
declare void @llvm.memmove.p1.p3.i256(ptr addrspace(1), ptr addrspace(3), i256, i1 immarg)

define void @expand_unknown_p1_p1(ptr addrspace(1) %dst, ptr addrspace(1) %src, i256 %size) {
; CHECK-LABEL: define void @expand_unknown_p1_p1
; CHECK-SAME: (ptr addrspace(1) [[DST:%.*]], ptr addrspace(1) [[SRC:%.*]], i256 [[SIZE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOOP_BYTES_COUNT:%.*]] = and i256 [[SIZE]], -32
; CHECK-NEXT:    [[RESIDUAL_BYTES:%.*]] = and i256 [[SIZE]], 31
; CHECK-NEXT:    [[COMPARE_SRC_DST:%.*]] = icmp ult ptr addrspace(1) [[SRC]], [[DST]]
; CHECK-NEXT:    [[COMPARE_LCB_TO_0:%.*]] = icmp eq i256 [[LOOP_BYTES_COUNT]], 0
; CHECK-NEXT:    [[COMPARE_RB_TO_0:%.*]] = icmp eq i256 [[RESIDUAL_BYTES]], 0
; CHECK-NEXT:    br i1 [[COMPARE_SRC_DST]], label [[COPY_BACKWARDS:%.*]], label [[COPY_FORWARD:%.*]]
; CHECK:       copy-backwards:
; CHECK-NEXT:    br i1 [[COMPARE_LCB_TO_0]], label [[COPY_BACKWARDS_RESIDUAL_COND:%.*]], label [[COPY_BACKWARDS_LOOP_PREHEADER:%.*]]
; CHECK:       copy-backwards-residual-cond:
; CHECK-NEXT:    br i1 [[COMPARE_RB_TO_0]], label [[MEMMOVE_DONE:%.*]], label [[MEMMOVE_RESIDUAL:%.*]]
; CHECK:       copy-backwards-loop-preheader:
; CHECK-NEXT:    [[SRC_BWD_RES_END:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[SRC]], i256 [[RESIDUAL_BYTES]]
; CHECK-NEXT:    [[SRC_BWD_START:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[SRC_BWD_RES_END]], i256 -32
; CHECK-NEXT:    [[DST_BWD_RES_END:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[DST]], i256 [[RESIDUAL_BYTES]]
; CHECK-NEXT:    [[DST_BWD_START:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[DST_BWD_RES_END]], i256 -32
; CHECK-NEXT:    br label [[COPY_BACKWARDS_LOOP:%.*]]
; CHECK:       copy-backwards-loop:
; CHECK-NEXT:    [[BYTES_COUNT:%.*]] = phi i256 [ [[DECREMENT_BYTES:%.*]], [[COPY_BACKWARDS_LOOP]] ], [ [[LOOP_BYTES_COUNT]], [[COPY_BACKWARDS_LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[LOAD_ADDR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[SRC_BWD_START]], i256 [[BYTES_COUNT]]
; CHECK-NEXT:    [[ELEMENT:%.*]] = load i256, ptr addrspace(1) [[LOAD_ADDR]], align 1
; CHECK-NEXT:    [[STORE_ADDR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[DST_BWD_START]], i256 [[BYTES_COUNT]]
; CHECK-NEXT:    store i256 [[ELEMENT]], ptr addrspace(1) [[STORE_ADDR]], align 1
; CHECK-NEXT:    [[DECREMENT_BYTES]] = sub i256 [[BYTES_COUNT]], 32
; CHECK-NEXT:    [[COMPARE_BYTES:%.*]] = icmp eq i256 [[DECREMENT_BYTES]], 0
; CHECK-NEXT:    br i1 [[COMPARE_BYTES]], label [[COPY_BACKWARDS_RESIDUAL_COND]], label [[COPY_BACKWARDS_LOOP]]
; CHECK:       copy-forward:
; CHECK-NEXT:    br i1 [[COMPARE_LCB_TO_0]], label [[COPY_FORWARD_RESIDUAL_COND:%.*]], label [[COPY_FORWARD_LOOP_PREHEADER:%.*]]
; CHECK:       copy-forward-residual-cond:
; CHECK-NEXT:    br i1 [[COMPARE_RB_TO_0]], label [[MEMMOVE_DONE]], label [[COPY_FORWARD_RESIDUAL:%.*]]
; CHECK:       copy-forward-loop-preheader:
; CHECK-NEXT:    br label [[COPY_FORWARD_LOOP:%.*]]
; CHECK:       copy-forward-loop:
; CHECK-NEXT:    [[BYTES_COUNT1:%.*]] = phi i256 [ [[INCREMENT_BYTES:%.*]], [[COPY_FORWARD_LOOP]] ], [ 0, [[COPY_FORWARD_LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[LOAD_ADDR2:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[SRC]], i256 [[BYTES_COUNT1]]
; CHECK-NEXT:    [[ELEMENT3:%.*]] = load i256, ptr addrspace(1) [[LOAD_ADDR2]], align 1
; CHECK-NEXT:    [[STORE_ADDR4:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[DST]], i256 [[BYTES_COUNT1]]
; CHECK-NEXT:    store i256 [[ELEMENT3]], ptr addrspace(1) [[STORE_ADDR4]], align 1
; CHECK-NEXT:    [[INCREMENT_BYTES]] = add i256 [[BYTES_COUNT1]], 32
; CHECK-NEXT:    [[COMPARE_BYTES5:%.*]] = icmp eq i256 [[INCREMENT_BYTES]], [[LOOP_BYTES_COUNT]]
; CHECK-NEXT:    br i1 [[COMPARE_BYTES5]], label [[COPY_FORWARD_LOOP_EXIT:%.*]], label [[COPY_FORWARD_LOOP]]
; CHECK:       copy-forward-loop-exit:
; CHECK-NEXT:    br label [[COPY_FORWARD_RESIDUAL_COND]]
; CHECK:       copy-forward-residual:
; CHECK-NEXT:    [[SRC_FWD_RES_ADDR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[SRC]], i256 [[LOOP_BYTES_COUNT]]
; CHECK-NEXT:    [[DST_FWD_RES_ADR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[DST]], i256 [[LOOP_BYTES_COUNT]]
; CHECK-NEXT:    br label [[MEMMOVE_RESIDUAL]]
; CHECK:       memmove-residual:
; CHECK-NEXT:    [[SRC_RES_ADDR:%.*]] = phi ptr addrspace(1) [ [[SRC_FWD_RES_ADDR]], [[COPY_FORWARD_RESIDUAL]] ], [ [[SRC]], [[COPY_BACKWARDS_RESIDUAL_COND]] ]
; CHECK-NEXT:    [[DST_RES_ADDR:%.*]] = phi ptr addrspace(1) [ [[DST_FWD_RES_ADR]], [[COPY_FORWARD_RESIDUAL]] ], [ [[DST]], [[COPY_BACKWARDS_RESIDUAL_COND]] ]
; CHECK-NEXT:    [[SRC_LOAD:%.*]] = load i256, ptr addrspace(1) [[SRC_RES_ADDR]], align 1
; CHECK-NEXT:    [[RES_BITS:%.*]] = mul i256 8, [[RESIDUAL_BYTES]]
; CHECK-NEXT:    [[UPPER_BITS:%.*]] = sub i256 256, [[RES_BITS]]
; CHECK-NEXT:    [[SRC_MASK:%.*]] = shl i256 -1, [[UPPER_BITS]]
; CHECK-NEXT:    [[SRC_MASKED:%.*]] = and i256 [[SRC_LOAD]], [[SRC_MASK]]
; CHECK-NEXT:    [[DST_LOAD:%.*]] = load i256, ptr addrspace(1) [[DST_RES_ADDR]], align 1
; CHECK-NEXT:    [[DST_MASK:%.*]] = lshr i256 -1, [[RES_BITS]]
; CHECK-NEXT:    [[DST_MASKED:%.*]] = and i256 [[DST_LOAD]], [[DST_MASK]]
; CHECK-NEXT:    [[STORE_ELEMENT:%.*]] = or i256 [[SRC_MASKED]], [[DST_MASKED]]
; CHECK-NEXT:    store i256 [[STORE_ELEMENT]], ptr addrspace(1) [[DST_RES_ADDR]], align 1
; CHECK-NEXT:    br label [[MEMMOVE_DONE]]
; CHECK:       memmove-done:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memmove.p1.p1.i256(ptr addrspace(1) %dst, ptr addrspace(1) %src, i256 %size, i1 false)
  ret void
}

; Optimizations that are run after this pass will remove unneeded code,
; as it is shown in memmove-expansion-asm.ll test in function with the
; same name.
define i256 @expand_known_backward() {
; CHECK-LABEL: define i256 @expand_known_backward() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COMPARE_SRC_DST:%.*]] = icmp ult ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), inttoptr (i256 100 to ptr addrspace(1))
; CHECK-NEXT:    [[COMPARE_LCB_TO_0:%.*]] = icmp eq i256 64, 0
; CHECK-NEXT:    [[COMPARE_RB_TO_0:%.*]] = icmp eq i256 31, 0
; CHECK-NEXT:    br i1 [[COMPARE_SRC_DST]], label [[COPY_BACKWARDS:%.*]], label [[COPY_FORWARD:%.*]]
; CHECK:       copy-backwards:
; CHECK-NEXT:    br i1 [[COMPARE_LCB_TO_0]], label [[COPY_BACKWARDS_RESIDUAL_COND:%.*]], label [[COPY_BACKWARDS_LOOP_PREHEADER:%.*]]
; CHECK:       copy-backwards-residual-cond:
; CHECK-NEXT:    br i1 [[COMPARE_RB_TO_0]], label [[MEMMOVE_DONE:%.*]], label [[MEMMOVE_RESIDUAL:%.*]]
; CHECK:       copy-backwards-loop-preheader:
; CHECK-NEXT:    br label [[COPY_BACKWARDS_LOOP:%.*]]
; CHECK:       copy-backwards-loop:
; CHECK-NEXT:    [[BYTES_COUNT:%.*]] = phi i256 [ [[DECREMENT_BYTES:%.*]], [[COPY_BACKWARDS_LOOP]] ], [ 64, [[COPY_BACKWARDS_LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[LOAD_ADDR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 31), i256 -32), i256 [[BYTES_COUNT]]
; CHECK-NEXT:    [[ELEMENT:%.*]] = load i256, ptr addrspace(1) [[LOAD_ADDR]], align 1
; CHECK-NEXT:    [[STORE_ADDR:%.*]] = getelementptr inbounds i8, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 31), i256 -32), i256 [[BYTES_COUNT]]
; CHECK-NEXT:    store i256 [[ELEMENT]], ptr addrspace(1) [[STORE_ADDR]], align 1
; CHECK-NEXT:    [[DECREMENT_BYTES]] = sub i256 [[BYTES_COUNT]], 32
; CHECK-NEXT:    [[COMPARE_BYTES:%.*]] = icmp eq i256 [[DECREMENT_BYTES]], 0
; CHECK-NEXT:    br i1 [[COMPARE_BYTES]], label [[COPY_BACKWARDS_RESIDUAL_COND]], label [[COPY_BACKWARDS_LOOP]]
; CHECK:       copy-forward:
; CHECK-NEXT:    br i1 [[COMPARE_LCB_TO_0]], label [[COPY_FORWARD_RESIDUAL_COND:%.*]], label [[COPY_FORWARD_LOOP_PREHEADER:%.*]]
; CHECK:       copy-forward-residual-cond:
; CHECK-NEXT:    br i1 [[COMPARE_RB_TO_0]], label [[MEMMOVE_DONE]], label [[COPY_FORWARD_RESIDUAL:%.*]]
; CHECK:       copy-forward-loop-preheader:
; CHECK-NEXT:    br label [[COPY_FORWARD_LOOP:%.*]]
; CHECK:       copy-forward-loop:
; CHECK-NEXT:    [[BYTES_COUNT1:%.*]] = phi i256 [ [[INCREMENT_BYTES:%.*]], [[COPY_FORWARD_LOOP]] ], [ 0, [[COPY_FORWARD_LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[LOAD_ADDR2:%.*]] = getelementptr inbounds i8, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 [[BYTES_COUNT1]]
; CHECK-NEXT:    [[ELEMENT3:%.*]] = load i256, ptr addrspace(1) [[LOAD_ADDR2]], align 1
; CHECK-NEXT:    [[STORE_ADDR4:%.*]] = getelementptr inbounds i8, ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 [[BYTES_COUNT1]]
; CHECK-NEXT:    store i256 [[ELEMENT3]], ptr addrspace(1) [[STORE_ADDR4]], align 1
; CHECK-NEXT:    [[INCREMENT_BYTES]] = add i256 [[BYTES_COUNT1]], 32
; CHECK-NEXT:    [[COMPARE_BYTES5:%.*]] = icmp eq i256 [[INCREMENT_BYTES]], 64
; CHECK-NEXT:    br i1 [[COMPARE_BYTES5]], label [[COPY_FORWARD_LOOP_EXIT:%.*]], label [[COPY_FORWARD_LOOP]]
; CHECK:       copy-forward-loop-exit:
; CHECK-NEXT:    br label [[COPY_FORWARD_RESIDUAL_COND]]
; CHECK:       copy-forward-residual:
; CHECK-NEXT:    br label [[MEMMOVE_RESIDUAL]]
; CHECK:       memmove-residual:
; CHECK-NEXT:    [[SRC_RES_ADDR:%.*]] = phi ptr addrspace(1) [ getelementptr inbounds (i8, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 64), [[COPY_FORWARD_RESIDUAL]] ], [ inttoptr (i256 10 to ptr addrspace(1)), [[COPY_BACKWARDS_RESIDUAL_COND]] ]
; CHECK-NEXT:    [[DST_RES_ADDR:%.*]] = phi ptr addrspace(1) [ getelementptr inbounds (i8, ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 64), [[COPY_FORWARD_RESIDUAL]] ], [ inttoptr (i256 100 to ptr addrspace(1)), [[COPY_BACKWARDS_RESIDUAL_COND]] ]
; CHECK-NEXT:    [[SRC_LOAD:%.*]] = load i256, ptr addrspace(1) [[SRC_RES_ADDR]], align 1
; CHECK-NEXT:    [[SRC_MASKED:%.*]] = and i256 [[SRC_LOAD]], -256
; CHECK-NEXT:    [[DST_LOAD:%.*]] = load i256, ptr addrspace(1) [[DST_RES_ADDR]], align 1
; CHECK-NEXT:    [[DST_MASKED:%.*]] = and i256 [[DST_LOAD]], 255
; CHECK-NEXT:    [[STORE_ELEMENT:%.*]] = or i256 [[SRC_MASKED]], [[DST_MASKED]]
; CHECK-NEXT:    store i256 [[STORE_ELEMENT]], ptr addrspace(1) [[DST_RES_ADDR]], align 1
; CHECK-NEXT:    br label [[MEMMOVE_DONE]]
; CHECK:       memmove-done:
; CHECK-NEXT:    ret i256 0
;
entry:
  tail call void @llvm.memmove.p1.p1.i256(ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 95, i1 false)
  ret i256 0
}

; Test that we called memcpy implementation.
define void @expand_unknown_p1_p3(ptr addrspace(1) %dst, ptr addrspace(3) %src, i256 %size) {
; CHECK-LABEL: define void @expand_unknown_p1_p3
; CHECK-SAME: (ptr addrspace(1) [[DST:%.*]], ptr addrspace(3) [[SRC:%.*]], i256 [[SIZE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOOP_COUNT:%.*]] = udiv i256 [[SIZE]], 32
; CHECK-NEXT:    [[RESIDUAL_BYTES:%.*]] = urem i256 [[SIZE]], 32
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne i256 [[LOOP_COUNT]], 0
; CHECK-NEXT:    br i1 [[TMP0]], label [[LOAD_STORE_LOOP_PREHEADER:%.*]], label [[MEMCPY_RESIDUAL_COND:%.*]]
; CHECK:       load-store-loop-preheader:
; CHECK-NEXT:    br label [[LOAD_STORE_LOOP:%.*]]
; CHECK:       load-store-loop:
; CHECK-NEXT:    [[LOOP_INDEX:%.*]] = phi i256 [ 0, [[LOAD_STORE_LOOP_PREHEADER]] ], [ [[TMP4:%.*]], [[LOAD_STORE_LOOP]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i256, ptr addrspace(3) [[SRC]], i256 [[LOOP_INDEX]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i256, ptr addrspace(3) [[TMP1]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i256, ptr addrspace(1) [[DST]], i256 [[LOOP_INDEX]]
; CHECK-NEXT:    store i256 [[TMP2]], ptr addrspace(1) [[TMP3]], align 1
; CHECK-NEXT:    [[TMP4]] = add i256 [[LOOP_INDEX]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ult i256 [[TMP4]], [[LOOP_COUNT]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[LOAD_STORE_LOOP]], label [[LOAD_STORE_LOOP_EXIT:%.*]]
; CHECK:       load-store-loop-exit:
; CHECK-NEXT:    br label [[MEMCPY_RESIDUAL_COND]]
; CHECK:       memcpy-residual-cond:
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i256 [[RESIDUAL_BYTES]], 0
; CHECK-NEXT:    br i1 [[TMP6]], label [[MEMCPY_RESIDUAL:%.*]], label [[MEMCPY_SPLIT:%.*]]
; CHECK:       memcpy-residual:
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i256, ptr addrspace(3) [[SRC]], i256 [[LOOP_COUNT]]
; CHECK-NEXT:    [[TMP8:%.*]] = load i256, ptr addrspace(3) [[TMP7]], align 1
; CHECK-NEXT:    [[TMP9:%.*]] = mul i256 8, [[RESIDUAL_BYTES]]
; CHECK-NEXT:    [[TMP10:%.*]] = sub i256 256, [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = shl i256 -1, [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = and i256 [[TMP8]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i256, ptr addrspace(1) [[DST]], i256 [[LOOP_COUNT]]
; CHECK-NEXT:    [[TMP14:%.*]] = load i256, ptr addrspace(1) [[TMP13]], align 1
; CHECK-NEXT:    [[TMP15:%.*]] = lshr i256 -1, [[TMP9]]
; CHECK-NEXT:    [[TMP16:%.*]] = and i256 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    [[TMP17:%.*]] = or i256 [[TMP12]], [[TMP16]]
; CHECK-NEXT:    store i256 [[TMP17]], ptr addrspace(1) [[TMP13]], align 1
; CHECK-NEXT:    br label [[MEMCPY_SPLIT]]
; CHECK:       memcpy-split:
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memmove.p1.p3.i256(ptr addrspace(1) %dst, ptr addrspace(3) %src, i256 %size, i1 false)
  ret void
}

; Test that we called memcpy implementation.
define void @expand_known_forward() {
; CHECK-LABEL: define void @expand_known_forward() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOAD_STORE_LOOP:%.*]]
; CHECK:       load-store-loop:
; CHECK-NEXT:    [[LOOP_INDEX:%.*]] = phi i256 [ 0, [[ENTRY:%.*]] ], [ [[TMP3:%.*]], [[LOAD_STORE_LOOP]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i256, ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 [[LOOP_INDEX]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i256, ptr addrspace(1) [[TMP0]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i256, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 [[LOOP_INDEX]]
; CHECK-NEXT:    store i256 [[TMP1]], ptr addrspace(1) [[TMP2]], align 1
; CHECK-NEXT:    [[TMP3]] = add i256 [[LOOP_INDEX]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ult i256 [[TMP3]], 2
; CHECK-NEXT:    br i1 [[TMP4]], label [[LOAD_STORE_LOOP]], label [[MEMCPY_SPLIT:%.*]]
; CHECK:       memcpy-split:
; CHECK-NEXT:    [[TMP5:%.*]] = load i256, ptr addrspace(1) getelementptr inbounds (i256, ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 2), align 1
; CHECK-NEXT:    [[TMP6:%.*]] = and i256 [[TMP5]], -256
; CHECK-NEXT:    [[TMP7:%.*]] = load i256, ptr addrspace(1) getelementptr inbounds (i256, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 2), align 1
; CHECK-NEXT:    [[TMP8:%.*]] = and i256 [[TMP7]], 255
; CHECK-NEXT:    [[TMP9:%.*]] = or i256 [[TMP6]], [[TMP8]]
; CHECK-NEXT:    store i256 [[TMP9]], ptr addrspace(1) getelementptr inbounds (i256, ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), i256 2), align 1
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memmove.p1.p1.i256(ptr addrspace(1) inttoptr (i256 10 to ptr addrspace(1)), ptr addrspace(1) inttoptr (i256 100 to ptr addrspace(1)), i256 95, i1 false)
  ret void
}
