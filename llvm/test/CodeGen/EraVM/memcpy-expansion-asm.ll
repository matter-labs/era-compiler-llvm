; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -O3 < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

declare void @llvm.memcpy.p1.p1.i256(ptr addrspace(1), ptr addrspace(1), i256, i1 immarg)
declare void @llvm.memcpy.p1.p3.i256(ptr addrspace(1), ptr addrspace(3), i256, i1 immarg)

define void @expand_unknown_p1_p3(ptr addrspace(1) %dest, ptr addrspace(3) %src, i256 %size) {
; CHECK-LABEL: expand_unknown_p1_p3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    and! code[@CPI0_0], r3, r4
; CHECK-NEXT:    and 31, r3, r5
; CHECK-NEXT:    add r1, r4, r3
; CHECK-NEXT:    jump.eq @.BB0_3
; CHECK-NEXT:  ; %bb.1: ; %load-store-loop-preheader
; CHECK-NEXT:    ptr.add r2, r0, r6
; CHECK-NEXT:  .BB0_2: ; %load-store-loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld.inc r6, r7, r6
; CHECK-NEXT:    st.1.inc r1, r7, r1
; CHECK-NEXT:    sub! r1, r3, r0
; CHECK-NEXT:    jump.ne @.BB0_2
; CHECK-NEXT:  .BB0_3: ; %memcpy-residual-cond
; CHECK-NEXT:    sub! r5, r0, r0
; CHECK-NEXT:    jump.eq @.BB0_5
; CHECK-NEXT:  ; %bb.4: ; %memcpy-residual
; CHECK-NEXT:    ptr.add r2, r4, r1
; CHECK-NEXT:    shl.s 3, r5, r2
; CHECK-NEXT:    ld.1 r3, r4
; CHECK-NEXT:    shl r4, r2, r4
; CHECK-NEXT:    shr r4, r2, r4
; CHECK-NEXT:    ld r1, r1
; CHECK-NEXT:    sub 256, r2, r2
; CHECK-NEXT:    shr r1, r2, r1
; CHECK-NEXT:    shl r1, r2, r1
; CHECK-NEXT:    or r1, r4, r1
; CHECK-NEXT:    st.1 r3, r1
; CHECK-NEXT:  .BB0_5: ; %memcpy-split
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) %dest, ptr addrspace(3) %src, i256 %size, i1 false)
  ret void
}

define void @expand_unknown_p1_p1(ptr addrspace(1) %dest, ptr addrspace(1) %src, i256 %size) {
; CHECK-LABEL: expand_unknown_p1_p1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    and! code[@CPI1_0], r3, r4
; CHECK-NEXT:    and 31, r3, r5
; CHECK-NEXT:    add r1, r4, r3
; CHECK-NEXT:    jump.eq @.BB1_3
; CHECK-NEXT:  ; %bb.1: ; %load-store-loop-preheader
; CHECK-NEXT:    add r2, r0, r6
; CHECK-NEXT:  .BB1_2: ; %load-store-loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld.1.inc r6, r7, r6
; CHECK-NEXT:    st.1.inc r1, r7, r1
; CHECK-NEXT:    sub! r1, r3, r0
; CHECK-NEXT:    jump.ne @.BB1_2
; CHECK-NEXT:  .BB1_3: ; %memcpy-residual-cond
; CHECK-NEXT:    sub! r5, r0, r0
; CHECK-NEXT:    jump.eq @.BB1_5
; CHECK-NEXT:  ; %bb.4: ; %memcpy-residual
; CHECK-NEXT:    add r2, r4, r1
; CHECK-NEXT:    shl.s 3, r5, r2
; CHECK-NEXT:    ld.1 r3, r4
; CHECK-NEXT:    shl r4, r2, r4
; CHECK-NEXT:    shr r4, r2, r4
; CHECK-NEXT:    ld.1 r1, r1
; CHECK-NEXT:    sub 256, r2, r2
; CHECK-NEXT:    shr r1, r2, r1
; CHECK-NEXT:    shl r1, r2, r1
; CHECK-NEXT:    or r1, r4, r1
; CHECK-NEXT:    st.1 r3, r1
; CHECK-NEXT:  .BB1_5: ; %memcpy-split
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p1.i256(ptr addrspace(1) %dest, ptr addrspace(1) %src, i256 %size, i1 false)
  ret void
}

define void @expand_known_p1_p3_loop_iter1(ptr addrspace(1) %dest, ptr addrspace(3) %src) {
; CHECK-LABEL: expand_known_p1_p3_loop_iter1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    ld.inc r2, r2, r3
; CHECK-NEXT:    st.1.inc r1, r2, r1
; CHECK-NEXT:    ld.1 r1, r2
; CHECK-NEXT:    and code[@CPI2_0], r2, r2
; CHECK-NEXT:    ld r3, r3
; CHECK-NEXT:    and code[@CPI2_1], r3, r3
; CHECK-NEXT:    or r3, r2, r2
; CHECK-NEXT:    st.1 r1, r2
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) %dest, ptr addrspace(3) %src, i256 42, i1 false)
  ret void
}

define void @expand_known_p1_p1_loop_iter1(ptr addrspace(1) %dest, ptr addrspace(1) %src) {
; CHECK-LABEL: expand_known_p1_p1_loop_iter1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    ld.1.inc r2, r2, r3
; CHECK-NEXT:    st.1.inc r1, r2, r1
; CHECK-NEXT:    ld.1 r1, r2
; CHECK-NEXT:    and code[@CPI3_0], r2, r2
; CHECK-NEXT:    ld.1 r3, r3
; CHECK-NEXT:    and code[@CPI3_1], r3, r3
; CHECK-NEXT:    or r3, r2, r2
; CHECK-NEXT:    st.1 r1, r2
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p1.i256(ptr addrspace(1) %dest, ptr addrspace(1) %src, i256 42, i1 false)
  ret void
}

define void @expand_known_p1_p3_loop_iter2(ptr addrspace(1) %dest, ptr addrspace(3) %src) {
; CHECK-LABEL: expand_known_p1_p3_loop_iter2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    add 64, r1, r3
; CHECK-NEXT:    ptr.add r2, r0, r4
; CHECK-NEXT:  .BB4_1: ; %load-store-loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld.inc r4, r5, r4
; CHECK-NEXT:    st.1.inc r1, r5, r1
; CHECK-NEXT:    sub! r1, r3, r0
; CHECK-NEXT:    jump.ne @.BB4_1
; CHECK-NEXT:  ; %bb.2: ; %memcpy-split
; CHECK-NEXT:    ld.1 r3, r1
; CHECK-NEXT:    and code[@CPI4_0], r1, r1
; CHECK-NEXT:    ptr.add.s 64, r2, r2
; CHECK-NEXT:    ld r2, r2
; CHECK-NEXT:    and code[@CPI4_1], r2, r2
; CHECK-NEXT:    or r2, r1, r1
; CHECK-NEXT:    st.1 r3, r1
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) %dest, ptr addrspace(3) %src, i256 84, i1 false)
  ret void
}

define void @expand_known_p1_p1_loop_iter2(ptr addrspace(1) %dest, ptr addrspace(1) %src) {
; CHECK-LABEL: expand_known_p1_p1_loop_iter2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    add 64, r1, r3
; CHECK-NEXT:    add r2, r0, r4
; CHECK-NEXT:  .BB5_1: ; %load-store-loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld.1.inc r4, r5, r4
; CHECK-NEXT:    st.1.inc r1, r5, r1
; CHECK-NEXT:    sub! r1, r3, r0
; CHECK-NEXT:    jump.ne @.BB5_1
; CHECK-NEXT:  ; %bb.2: ; %memcpy-split
; CHECK-NEXT:    ld.1 r3, r1
; CHECK-NEXT:    and code[@CPI5_0], r1, r1
; CHECK-NEXT:    add 64, r2, r2
; CHECK-NEXT:    ld.1 r2, r2
; CHECK-NEXT:    and code[@CPI5_1], r2, r2
; CHECK-NEXT:    or r2, r1, r1
; CHECK-NEXT:    st.1 r3, r1
; CHECK-NEXT:    ret
entry:
  call void @llvm.memcpy.p1.p1.i256(ptr addrspace(1) %dest, ptr addrspace(1) %src, i256 84, i1 false)
  ret void
}
