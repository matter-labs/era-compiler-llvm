; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

@val = addrspace(4) global i256 42

define i256 @rolrrr(i256 %rs1, i256 %rs2) {
; CHECK-LABEL: rolrrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rol r1, r2, r1
; CHECK-NEXT:    ret
entry:
  %sub = sub i256 256, %rs2
  %shl = shl i256 %rs1, %rs2
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolirr(i256 %rs1) {
; CHECK-LABEL: rolirr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rol 20, r1, r1
; CHECK-NEXT:    ret
entry:
  %sub = sub i256 256, %rs1
  %shl = shl i256 20, %rs1
  %lshr = lshr i256 20, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolxrr(i256 %rs1) {
; CHECK-LABEL: rolxrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rol.s 20, r1, r1
; CHECK-NEXT:    ret
entry:
  %shl = shl i256 %rs1, 20
  %lshr = lshr i256 %rs1, 236
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolcrr(i256 %rs1) {
; CHECK-LABEL: rolcrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rol @val[0], r1, r1
; CHECK-NEXT:    ret
entry:
  %val = load i256, i256 addrspace(4)* @val
  %sub = sub i256 256, %rs1
  %shl = shl i256 %val, %rs1
  %lshr = lshr i256 %val, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolyrr(i256 %rs1) {
; CHECK-LABEL: rolyrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rol.s @val[0], r1, r1
; CHECK-NEXT:    ret
entry:
  %val = load i256, i256 addrspace(4)* @val
  %sub = sub i256 256, %val
  %shl = shl i256 %rs1, %val
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolsrr(i256 %rs1) {
; CHECK-LABEL: rolsrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol stack-[1], r1, r1
; CHECK-NEXT:    ret
entry:
  %valptr = alloca i256
  %val = load i256, i256* %valptr
  %sub = sub i256 256, %rs1
  %shl = shl i256 %val, %rs1
  %lshr = lshr i256 %val, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define i256 @rolzrr(i256 %rs1) {
; CHECK-LABEL: rolzrr:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol.s stack-[1], r1, r1
; CHECK-NEXT:    ret
entry:
  %valptr = alloca i256
  %val = load i256, i256* %valptr
  %sub = sub i256 256, %val
  %shl = shl i256 %rs1, %val
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  ret i256 %or
}

define void @rolrrs(i256 %rs1, i256 %rs2) {
; CHECK-LABEL: rolrrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol r1, r2, stack-[1]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %sub = sub i256 256, %rs2
  %shl = shl i256 %rs1, %rs2
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolirs(i256 %rs1) {
; CHECK-LABEL: rolirs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol 20, r1, stack-[1]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %sub = sub i256 256, %rs1
  %shl = shl i256 20, %rs1
  %lshr = lshr i256 20, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolxrs(i256 %rs1) {
; CHECK-LABEL: rolxrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol.s 20, r1, stack-[1]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %shl = shl i256 %rs1, 20
  %lshr = lshr i256 %rs1, 236
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolcrs(i256 %rs1) {
; CHECK-LABEL: rolcrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol @val[0], r1, stack-[1]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %val = load i256, i256 addrspace(4)* @val
  %sub = sub i256 256, %rs1
  %shl = shl i256 %val, %rs1
  %lshr = lshr i256 %val, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolyrs(i256 %rs1) {
; CHECK-LABEL: rolyrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[1]
; CHECK-NEXT:    rol.s @val[0], r1, stack-[1]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %val = load i256, i256 addrspace(4)* @val
  %sub = sub i256 256, %val
  %shl = shl i256 %rs1, %val
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolsrs(i256 %rs1) {
; CHECK-LABEL: rolsrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[2]
; CHECK-NEXT:    rol stack-[1], r1, stack-[2]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %valptr = alloca i256
  %val = load i256, i256* %valptr
  %sub = sub i256 256, %rs1
  %shl = shl i256 %val, %rs1
  %lshr = lshr i256 %val, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}

define void @rolzrs(i256 %rs1) {
; CHECK-LABEL: rolzrs:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    nop stack+=[2]
; CHECK-NEXT:    rol.s stack-[1], r1, stack-[2]
; CHECK-NEXT:    ret
entry:
  %destptr = alloca i256
  %valptr = alloca i256
  %val = load i256, i256* %valptr
  %sub = sub i256 256, %val
  %shl = shl i256 %rs1, %val
  %lshr = lshr i256 %rs1, %sub
  %or = or i256 %shl, %lshr
  store i256 %or, i256* %destptr
  ret void
}
