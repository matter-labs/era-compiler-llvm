; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s | FileCheck %s

target datalayout = "E-p:256:256-i256:256:256-S32-a:256:256"
target triple = "eravm"

define i256 @test_add_code(i256 %0, i256 %1) {
; CHECK-LABEL: test_add_code:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB0_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB0_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB0_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.s.ne code[@CPI0_0], r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB0_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = add i256 %bb, 10245387
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_add_imm(i256 %0, i256 %1) {
; CHECK-LABEL: test_add_imm:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB1_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB1_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB1_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    add.ne 1024, r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB1_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = add i256 %bb, 1024
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_add_reg(i256 %0, i256 %1) {
; CHECK-LABEL: test_add_reg:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB2_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB2_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB2_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    add.ne r1, r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB2_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = add i256 %bb, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_reg(i256 %0, i256 %1, i256 %a) {
; CHECK-LABEL: test_sub_reg:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB3_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB3_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB3_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.ne r3, r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB3_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = sub i256 %a, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_imm(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_imm:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB4_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB4_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB4_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.s.ne 1024, r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB4_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = sub i256 %bb, 1024
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_imm2(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_imm2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB5_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB5_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB5_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.ne 1024, r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB5_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = sub i256 1024, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_code(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_code:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB6_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB6_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB6_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.s.ne code[@CPI6_0], r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB6_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = sub i256 %bb, 10242048
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_code2(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_code2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB7_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB7_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB7_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    sub.ne code[@CPI7_0], r1, r1
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB7_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = sub i256 10242048, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_mul_code(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_mul_code:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB8_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB8_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB8_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    mul.ne code[@CPI8_0], r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB8_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = mul i256 10242048, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_mul_imm(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_mul_imm:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB9_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB9_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB9_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    mul.ne 1025, r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB9_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = mul i256 1025, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_mul_reg(i256 %0, i256 %1, i256 %a) {
; CHECK-LABEL: test_sub_mul_reg:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB10_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB10_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB10_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    mul.ne r3, r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB10_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = mul i256 %a, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_div_imm(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_div_imm:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB11_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB11_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB11_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    div.ne 1025, r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB11_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = udiv i256 1025, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_div_imm2(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_div_imm2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB12_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB12_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB12_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    div.s.ne 1025, r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB12_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = udiv i256 %bb, 1025
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_div_code(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_div_code:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB13_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB13_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB13_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    div.ne code[@CPI13_0], r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB13_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = udiv i256 10242048, %bb
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_div_code2(i256 %0, i256 %1) {
; CHECK-LABEL: test_sub_div_code2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB14_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB14_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB14_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    div.s.ne code[@CPI14_0], r1, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB14_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = udiv i256 %bb, 10242048
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}

define i256 @test_sub_div_reg(i256 %0, i256 %1, i256 %a) {
; CHECK-LABEL: test_sub_div_reg:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sub! r1, r0, r0
; CHECK-NEXT:    jump.eq @.BB15_1
; CHECK-NEXT:  ; %bb.4:
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .BB15_1: ; %for_body.preheader
; CHECK-NEXT:    add 1024, r0, r1
; CHECK-NEXT:    and 2, r2, r2
; CHECK-NEXT:  .BB15_2: ; %for_body
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    and! 1, r1, r0
; CHECK-NEXT:    div.ne r1, r3, r1, r0
; CHECK-NEXT:    shr.s 1, r1, r1
; CHECK-NEXT:    sub! r2, r0, r0
; CHECK-NEXT:    jump.eq @.BB15_2
; CHECK-NEXT:  ; %bb.3: ; %exit_label
; CHECK-NEXT:    ret
entry:
  %b = add i256 0, 1024
  %comparison_result = icmp eq i256 %0, 0
  br i1 %comparison_result, label %for_body, label %exit_label

for_body:
  %bb = phi i256 [ %b_merge_shifted, %for_body ], [ %b, %entry ]
  %2 = and i256 %bb, 1
  %trunc_result = icmp eq i256 %2, 0
  %addition_result = udiv i256 %bb, %a
  %b_merge = select i1 %trunc_result, i256 %bb, i256 %addition_result
  %b_merge_shifted = lshr i256 %b_merge, 1
  %3 = and i256 %1, 2
  %cmp = icmp eq i256 %3, 0
  br i1 %cmp, label %for_body, label %exit_label

exit_label:
  %result = phi i256 [%b, %entry], [%b_merge_shifted, %for_body]
  ret i256 %result
}
