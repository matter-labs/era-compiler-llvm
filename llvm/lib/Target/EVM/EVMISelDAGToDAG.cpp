//===-------- EVMISelDAGToDAG.cpp - A dag to dag inst selector for EVM ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the EVM target.
//
//===----------------------------------------------------------------------===//

#include "EVM.h"
#include "EVMTargetMachine.h"
#include "MCTargetDesc/EVMMCTargetDesc.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "evm-isel"
#define PASS_NAME "EVM DAG->DAG Pattern Instruction Selection"

// EVMDAGToDAGISel - EVM specific code to select EVM machine
// instructions for SelectionDAG operations.

namespace {
class EVMDAGToDAGISel final : public SelectionDAGISel {
public:
  EVMDAGToDAGISel(EVMTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

private:

  // Include the pieces autogenerated from the target description.
#include "EVMGenDAGISel.inc"

  // Main method to transform nodes into machine nodes.
  void Select(SDNode *N) override;
};

class EVMDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  explicit EVMDAGToDAGISelLegacy(EVMTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISelLegacy(
            ID, std::make_unique<EVMDAGToDAGISel>(TM, OptLevel)) {}
};
} // end anonymous namespace

char EVMDAGToDAGISelLegacy::ID;

void EVMDAGToDAGISel::Select(SDNode *Node) {
  const SDLoc DL(Node);

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  switch (Node->getOpcode()) {
  case EVMISD::FCALL: {
    // FCALL has both variable operands and variable results, but ISel only
    // supports one or the other. Split calls into two nodes glued together, one
    // for the operands and one for the results. These two nodes will be
    // recombined in a custom inserter hook into a single MachineInstr.
    SmallVector<SDValue, 16> Ops;
    for (size_t I = 1; I < Node->getNumOperands(); ++I) {
      SDValue Op = Node->getOperand(I);
      if (I == 1 && Op->getOpcode() == EVMISD::TARGET_ADDR_WRAPPER)
        Op = Op->getOperand(0);
      Ops.push_back(Op);
    }

    // Add the chain last
    Ops.push_back(Node->getOperand(0));
    MachineSDNode *CallParams =
        CurDAG->getMachineNode(EVM::CALL_PARAMS, DL, MVT::Glue, Ops);

    SDValue Link(CallParams, 0);
    MachineSDNode *CallResults =
        CurDAG->getMachineNode(EVM::CALL_RESULTS, DL, Node->getVTList(), Link);
    ReplaceNode(Node, CallResults);
    return;
  }

  default:
    break;
  }

  // Select the default instruction
  SelectCode(Node);
}

// createEVMISelDag - This pass converts a legalized DAG into a
// EVM-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createEVMISelDag(EVMTargetMachine &TM,
                                     CodeGenOptLevel OptLevel) {
  return new EVMDAGToDAGISelLegacy(TM, OptLevel);
}
