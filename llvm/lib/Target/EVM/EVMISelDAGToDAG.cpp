//===-------- EVMISelDAGToDAG.cpp - A dag to dag inst selector for EVM ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the EVM target.
//
//===----------------------------------------------------------------------===//

#include "EVM.h"
#include "EVMTargetMachine.h"
#include "MCTargetDesc/EVMMCTargetDesc.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "evm-isel"
#define PASS_NAME "EVM DAG->DAG Pattern Instruction Selection"

// EVMDAGToDAGISel - EVM specific code to select EVM machine
// instructions for SelectionDAG operations.

namespace {
class EVMDAGToDAGISel final : public SelectionDAGISel {
public:
  EVMDAGToDAGISel(EVMTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

private:

  // Include the pieces autogenerated from the target description.
#include "EVMGenDAGISel.inc"

  // Main method to transform nodes into machine nodes.
  void Select(SDNode *N) override;
};

class EVMDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  explicit EVMDAGToDAGISelLegacy(EVMTargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISelLegacy(
            ID, std::make_unique<EVMDAGToDAGISel>(TM, OptLevel)) {}
};
} // end anonymous namespace

char EVMDAGToDAGISelLegacy::ID;

void EVMDAGToDAGISel::Select(SDNode *Node) {
  const SDLoc DL(Node);

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  switch (Node->getOpcode()) {
  case EVMISD::FCALL: {
    // FCALL has both variable operands and variable results, but ISel only
    // supports one or the other. Split calls into two nodes glued together, one
    // for the operands and one for the results. These two nodes will be
    // recombined in a custom inserter hook into a single MachineInstr.
    SmallVector<SDValue, 16> Ops;
    for (size_t I = 1; I < Node->getNumOperands(); ++I) {
      SDValue Op = Node->getOperand(I);
      if (I == 1 && Op->getOpcode() == EVMISD::TARGET_ADDR_WRAPPER)
        Op = Op->getOperand(0);
      Ops.push_back(Op);
    }

    // Add the chain last
    Ops.push_back(Node->getOperand(0));
    MachineSDNode *CallParams =
        CurDAG->getMachineNode(EVM::CALL_PARAMS, DL, MVT::Glue, Ops);

    SDValue Link(CallParams, 0);
    MachineSDNode *CallResults =
        CurDAG->getMachineNode(EVM::CALL_RESULTS, DL, Node->getVTList(), Link);
    ReplaceNode(Node, CallResults);
    return;
  }
  case ISD::Constant: {
    if (!CurDAG->shouldOptForSize())
      break;

    APInt Imm = cast<ConstantSDNode>(Node)->getAPIntValue();
    if (Imm.isZero())
      break;

    // Decompose an arbitrary immediate:
    //
    //   0x0000001...100000000
    //
    // into:
    //    - traling and leading zero bits
    //    - 'value' part, that starts and and ends with '1'
    //    - abs('value')
    //
    // The following transformations are considered, depending on their
    // cost-effectiveness:
    //   - ((0 - AbsVal) << shift_l) >> shift_r
    //   - Val << shift
    //
    unsigned Ones = Imm.popcount();
    unsigned TrailZ = Imm.countTrailingZeros();
    unsigned LeadZ = Imm.countLeadingZeros();
    APInt Val = Imm.extractBits(256 - TrailZ - LeadZ, TrailZ);
    unsigned ValLen = Val.getActiveBits();
    assert(ValLen == (256 - TrailZ - LeadZ));
    assert(Val.isNegative());
    APInt AbsVal = Val.abs();
    SDValue NegativeVal =
        SDValue(CurDAG->getMachineNode(
                    EVM::SUB, DL, MVT::i256,
                    CurDAG->getTargetConstant(0, DL, MVT::i256),
                    CurDAG->getTargetConstant(AbsVal.zext(256), DL, MVT::i256)),
                0);

    SDValue ShiftVal = CurDAG->getTargetConstant(256 - ValLen, DL, MVT::i256);
    if (!LeadZ && Ones > 4 * 8) {
      // 0xfffffe000000000
      // Costs:
      //   PUSH AbsVal      // 1 + sizeof(AbsVal)
      //   PUSH0            // 1
      //   SUB              // 1
      //   PUSH1 Shift1     // 2
      //   SHL              // 1
      //                    ---------
      //                    6 + sizeof(AbsVal)
      //
      MachineSDNode *SHL = CurDAG->getMachineNode(EVM::SHL, DL, MVT::i256,
                                                  ShiftVal, NegativeVal);
      ReplaceNode(Node, SHL);
      return;
    }

    bool IsMask = ((Ones + LeadZ + TrailZ) == Imm.getBitWidth());
    if (IsMask && !TrailZ && Ones > 6 * 8) {
      assert(AbsVal.isOne());
      // 0x0000000000ffffffffffff
      // Costs:
      //   PUSH 1           // 2
      //   PUSH0            // 1
      //   SUB              // 1
      //   PUSH1 Shift1     // 2
      //   SHL              // 1
      //                    ---------
      //                    7
      //
      MachineSDNode *SHR = CurDAG->getMachineNode(EVM::SHR, DL, MVT::i256,
                                                  ShiftVal, NegativeVal);
      ReplaceNode(Node, SHR);
      return;
    }

    if (ValLen > (AbsVal.getActiveBits() + 8 * 8)) {
      // 0x0000000000fffffffffffe000000000000
      // Costs:
      //   PUSH AbsVal      // 1 + sizeof(AbsVal)
      //   PUSH0            // 1
      //   SUB              // 1
      //   PUSH1 Shift1     // 2
      //   SHL              // 1
      //   PUSH1 Shift2     // 2
      //   SHR              // 1
      //                    ---------
      //                    9 + size(AbsVal)
      //
      SDValue SHL = SDValue(CurDAG->getMachineNode(EVM::SHL, DL, MVT::i256,
                                                   ShiftVal, NegativeVal),
                            0);
      SDValue ShiftRightVal = CurDAG->getTargetConstant(LeadZ, DL, MVT::i256);
      MachineSDNode *SHR =
          CurDAG->getMachineNode(EVM::SHR, DL, MVT::i256, ShiftRightVal, SHL);
      ReplaceNode(Node, SHR);
      return;
    }

    if (TrailZ > 3 * 8) {
      // Costs:
      //   PUSH1 Shift       // 2
      //   PUSH  ShiftedVal  // 1 + sizeof(ShiftedVal)
      //   SHL               // 1
      //                     ---------
      //                     4 + sizeof(ShiftedVal)
      //
      MachineSDNode *SHL = CurDAG->getMachineNode(
          EVM::SHL, DL, MVT::i256,
          CurDAG->getTargetConstant(TrailZ, DL, MVT::i256),
          CurDAG->getTargetConstant(Imm.lshr(TrailZ), DL, MVT::i256));
      ReplaceNode(Node, SHL);
      return;
    }
    // Default materialization cost: 1 + sizeof(Val)
  } break;
  default:
    break;
  }

  // Select the default instruction
  SelectCode(Node);
}

// createEVMISelDag - This pass converts a legalized DAG into a
// EVM-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createEVMISelDag(EVMTargetMachine &TM,
                                     CodeGenOptLevel OptLevel) {
  return new EVMDAGToDAGISelLegacy(TM, OptLevel);
}
