//===----- EVMInstPrinter.cpp - Convert EVM MCInst to assembly syntax -----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This class prints an EVM MCInst to a .s file.
//
//===----------------------------------------------------------------------===//

#include "EVMInstPrinter.h"
#include "MCTargetDesc/EVMMCTargetDesc.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/Support/FormattedStream.h"
using namespace llvm;

#define DEBUG_TYPE "asm-printer"

// Include the auto-generated portion of the assembly writer.
#include "EVMGenAsmWriter.inc"

void EVMInstPrinter::printRegName(raw_ostream &OS, MCRegister RegNo) const {
  // Decode the virtual register. This must be kept in sync with
  // EVMMCInstLower::encodeVirtualRegister.
  const unsigned RCId = (RegNo >> 28);
  switch (RCId) {
  default:
    report_fatal_error("Bad virtual register encoding");
  case 0:
    // This is actually a physical register, so defer to the autogenerated
    // register printer.
    OS << EVMInstPrinter::getRegisterName(RegNo);
    return;
  case 1:
    OS << "$";
    break;
  }

  const unsigned VReg = RegNo & 0x0FFFFFFF;
  OS << VReg;
}

void EVMInstPrinter::printInst(const MCInst *MI, uint64_t Address,
                               StringRef Annot, const MCSubtargetInfo &STI,
                               raw_ostream &O) {
  // Print the instruction manually instead of using the TableGen-generated
  // printInstruction() to allow custom formatting of the mnemonic.
  O << "\t";
  std::pair<const char *, uint64_t> MnemonicInfo = getMnemonic(MI);
  // Add padding to the mnemonic so that it is 16 characters long.
  O << left_justify(MnemonicInfo.first, /*Width=*/16);
  for (unsigned I = 0; I < MI->getNumOperands(); ++I)
    printOperand(MI, I, O);

  // Print any additional variadic operands.
  const MCInstrDesc &Desc = MII.get(MI->getOpcode());
  if (Desc.isVariadic()) {
    if ((Desc.getNumOperands() == 0 && MI->getNumOperands() > 0) ||
        Desc.variadicOpsAreDefs())
      O << " ";
    unsigned Start = Desc.getNumOperands();
    unsigned NumVariadicDefs = 0;
    if (Desc.variadicOpsAreDefs()) {
      // The number of variadic defs is encoded in an immediate by MCInstLower
      NumVariadicDefs = MI->getOperand(0).getImm();
      Start = 1;
    }
    bool NeedsComma = Desc.getNumOperands() > 0 && !Desc.variadicOpsAreDefs();
    for (auto I = Start, E = MI->getNumOperands(); I < E; ++I) {
      if (NeedsComma)
        O << ", ";
      printOperand(MI, I, O, I - Start < NumVariadicDefs);
      NeedsComma = true;
    }
  }

  // Print any added annotation.
  printAnnotation(O, Annot);
}

void EVMInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
                                  raw_ostream &O, bool IsVariadicDef) {
  const MCOperand &Op = MI->getOperand(OpNo);
  if (Op.isReg()) {
    printRegName(O, Op.getReg());
  } else if (Op.isImm()) {
    O << format_hex(Op.getImm(), 0, /*Upper=*/true);
  } else {
    Op.getExpr()->print(O, &MAI);
  }
}
