//===-- SyncVMISelDAGToDAG.cpp - A dag to dag inst selector for SyncVM ----===//
//
// This file defines an instruction selector for the SyncVM target.
//
//===----------------------------------------------------------------------===//

#include "SyncVM.h"
#include "SyncVMTargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/Config/llvm-config.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "syncvm-isel"

namespace {
struct SyncVMISelAddressMode {
  enum { RegBase, FrameIndexBase, StackRegBase } BaseType = RegBase;

  struct {
    SDValue Reg;
    int FrameIndex = 0;
  } Base;

  int64_t Disp = 0;
  const GlobalValue *GV = nullptr;

  bool isDefault() const {
    return !BaseType && !Base.Reg.getNode() && !Base.FrameIndex && !Disp && !GV;
  }

  bool isOnStack() const { return BaseType != RegBase; }

  SyncVMISelAddressMode() = default;

#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  LLVM_DUMP_METHOD void dump() {
    errs() << "SyncVMISelAddressMode " << this << '\n';
    if (Base.Reg.getNode() != nullptr) {
      errs() << "Base.Reg ";
      Base.Reg.getNode()->dump();
    }
    if (BaseType == FrameIndexBase) {
      errs() << " Base.FrameIndex " << Base.FrameIndex << '\n';
    }
    errs() << " Disp " << Disp << '\n';
    if (GV) {
      errs() << "GV ";
      GV->dump();
    }
  }
#endif
};
} // namespace

/// SyncVMDAGToDAGISel - SyncVM specific code to select SyncVM machine
/// instructions for SelectionDAG operations.
///
namespace {
class SyncVMDAGToDAGISel : public SelectionDAGISel {
public:
  SyncVMDAGToDAGISel(SyncVMTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

private:
  StringRef getPassName() const override {
    return "SyncVM DAG->DAG Pattern Instruction Selection";
  }

  bool MatchAddress(SDValue N, SyncVMISelAddressMode &AM, bool IsStackAddr);
  bool MatchAddressBase(SDValue N, SyncVMISelAddressMode &AM, bool IsStackAddr);

  // Include the pieces autogenerated from the target description.
#include "SyncVMGenDAGISel.inc"

  // Main method to transform nodes into machine nodes.
  void Select(SDNode *N) override;

  bool SelectInRegMemAddr(SDValue Addr, SDValue &Base);
  bool SelectMemAddr(SDValue Addr, SDValue &Base, SDValue &Disp);
  bool SelectStackAddr(SDValue Addr, SDValue &Base1, SDValue &Base2,
                       SDValue &Disp);
  bool SelectAdjStackAddr(SDValue Addr, SDValue &Base1, SDValue &Base2,
                          SDValue &Disp);
  bool SelectStackAddrCommon(SDValue Addr, SDValue &Base1, SDValue &Base2,
                             SDValue &Disp, bool IsAdjusted);
  // select load from stack address
  bool SelectSTACKLOAD(SDValue UMUL, SDValue &LOAD);

  // select if the addressing is done by single register.
  bool SelectStackAddrReg(SDValue UMUL, SDValue &Reg);

  bool SelectStackDIV(StoreSDNode* store);
  bool SelectStackMUL(StoreSDNode* store);
  using MapType = DenseMap<uint8_t, std::pair<unsigned, bool>>;

  bool SelectStackOperation(StoreSDNode *store, unsigned Operator,
                            const MapType &Mapping);

  SyncVMISelAddressMode MergeAddr(const SyncVMISelAddressMode &LHS,
                                  const SyncVMISelAddressMode &RHS, SDLoc DL);
};
} // end anonymous namespace

/// Merge \p LHS and \p RHS address modes as if they are added together.
/// The main goal is to transform patterns like (+ (+ fi reg), (* reg ci)) to
/// (+ (+ fi ci), NewReg) so SyncVM can select it.
SyncVMISelAddressMode
SyncVMDAGToDAGISel::MergeAddr(const SyncVMISelAddressMode &LHS,
                              const SyncVMISelAddressMode &RHS, SDLoc DL) {
  SyncVMISelAddressMode Result;
  Result.BaseType = SyncVMISelAddressMode::FrameIndexBase;
  Result.Base.FrameIndex = LHS.Base.FrameIndex | RHS.Base.FrameIndex;
  if (LHS.Base.Reg.getNode() && RHS.Base.Reg.getNode()) {
    Result.Base.Reg =
        CurDAG->getNode(ISD::ADD, DL, MVT::i256, LHS.Base.Reg, RHS.Base.Reg);
    SelectCode(Result.Base.Reg.getNode());
  } else if (LHS.Base.Reg.getNode()) {
    Result.Base.Reg = LHS.Base.Reg;
  } else if (RHS.Base.Reg.getNode()) {
    Result.Base.Reg = RHS.Base.Reg;
  }
  Result.Disp += LHS.Disp + RHS.Disp;
  return Result;
}

/// MatchAddressBase - Helper for MatchAddress. Add the specified node to the
/// specified addressing mode without any further recursion.
bool SyncVMDAGToDAGISel::MatchAddressBase(SDValue N, SyncVMISelAddressMode &AM,
                                          bool IsStackAddr) {
  if ((!IsStackAddr && AM.BaseType != SyncVMISelAddressMode::RegBase) ||
      AM.Base.Reg.getNode()) {
    // If so, we cannot select it.
    return true;
  }

  if (IsStackAddr && (N->getOpcode() == SyncVMISD::SELECT_CC ||
                      N->getOpcode() == ISD::UNDEF)) {
    AM.BaseType = SyncVMISelAddressMode::StackRegBase;
  }

  // Default, generate it as a register.
  AM.Base.Reg = N;
  return false;
}

bool SyncVMDAGToDAGISel::MatchAddress(SDValue N, SyncVMISelAddressMode &AM,
                                      bool IsStackAddr) {
  LLVM_DEBUG(errs() << "MatchAddress: "; AM.dump());

  switch (N.getOpcode()) {
  default: {
    break;
  }
  case ISD::Constant: {
    uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();
    AM.Disp += Val;
    return false;
  }
  case ISD::FrameIndex: {
    if (!IsStackAddr)
      return true;
    if (IsStackAddr && AM.BaseType == SyncVMISelAddressMode::RegBase) {
      AM.BaseType = SyncVMISelAddressMode::FrameIndexBase;
      AM.Base.FrameIndex = cast<FrameIndexSDNode>(N)->getIndex();
      return false;
    }
    break;
  }
  case ISD::TargetGlobalAddress: {
    auto *G = cast<GlobalAddressSDNode>(N);
    AM.GV = G->getGlobal();
    AM.Disp += G->getOffset();
    // Ext loads, trunc stores has offset in bits
    if ((isa<StoreSDNode>(N) && cast<StoreSDNode>(N)->isTruncatingStore()) ||
        (isa<LoadSDNode>(N) &&
         cast<LoadSDNode>(N)->getExtensionType() != ISD::NON_EXTLOAD))
      AM.Disp /= 8;
    return false;
  }
  case ISD::ADD: {
    SyncVMISelAddressMode Backup = AM;
    const SDValue &Operand0 = N.getNode()->getOperand(0);
    const SDValue &Operand1 = N.getNode()->getOperand(1);
    if (!MatchAddress(Operand0, AM, IsStackAddr) &&
        !MatchAddress(Operand1, AM, IsStackAddr))
      return false;
    AM = Backup;
    if (!MatchAddress(Operand1, AM, IsStackAddr) &&
        !MatchAddress(Operand0, AM, IsStackAddr))
      return false;
    AM = Backup;
    if (IsStackAddr)
      AM.BaseType = SyncVMISelAddressMode::StackRegBase;
    break;
  }
  case ISD::OR:
    // Handle "X | C" as "X + C" iff X is known to have C bits clear.
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      SyncVMISelAddressMode Backup = AM;
      uint64_t Offset = CN->getSExtValue();
      // Start with the LHS as an addr mode.
      if (!MatchAddress(N.getOperand(0), AM, IsStackAddr) &&
          // Address could not have picked a GV address for the displacement.
          AM.GV == nullptr &&
          // Check to see if the LHS & C is zero.
          CurDAG->MaskedValueIsZero(N.getOperand(0), CN->getAPIntValue())) {
        AM.Disp += Offset;
        return false;
      }
      AM = Backup;
    }
    break;
  case ISD::CopyFromReg:
    if (IsStackAddr)
      // The offset is in a register, no frame index involved
      AM.BaseType = SyncVMISelAddressMode::StackRegBase;
    break;
  case ISD::AssertZext:
    return MatchAddress(N->getOperand(0), AM, IsStackAddr);
  }
  return MatchAddressBase(N, AM, IsStackAddr);
}

bool SyncVMDAGToDAGISel::SelectInRegMemAddr(SDValue N, SDValue &Base) {
  outs() << "Select inmem\n";
  Base = N;
  return true;
}

/// SelectMemAddr - returns true if it is able pattern match an addressing mode
/// for heap, parent or child memory. It returns the operands which make up the
/// maximal addressing mode it can match by reference.
bool SyncVMDAGToDAGISel::SelectMemAddr(SDValue N, SDValue &Base,
                                       SDValue &Disp) {
  SyncVMISelAddressMode AM;

  auto Zero = CurDAG->getTargetConstant(0, SDLoc(N), MVT::i256);

  if (MatchAddress(N, AM, false /* IsStackAddr */)) {
    LLVM_DEBUG(errs() << "Failed to match address.");
    return false;
  } else {
    LLVM_DEBUG(errs() << "Matched: "; AM.dump());
  }

  // SyncVM doesn't support offsets by unaligned number of bytes, so add
  // the displacement to the base register.
  if (unsigned Unaligned = AM.Disp % 32) {
    if (AM.Base.Reg.getNode()) {
      auto AddToReg =
          CurDAG->getTargetConstant(AM.Disp % 32, SDLoc(N), MVT::i256);
      auto AddrNode = CurDAG->getMachineNode(
          SyncVM::ADDirr_s, SDLoc(N), MVT::i256, AM.Base.Reg, AddToReg, Zero);
      AM.Base.Reg = SDValue(AddrNode, 0);
    }
    AM.Disp -= AM.Disp % 32;
  }

  // TODO: Hack (constant is used to designate immediate addressing mode),
  // redesign.
  assert(AM.BaseType == SyncVMISelAddressMode::RegBase);
  if (!AM.Base.Reg.getNode())
    AM.Base.Reg = CurDAG->getTargetConstant(0, SDLoc(N), MVT::i256);

  Base = AM.Base.Reg;

  if (AM.GV)
    Disp = CurDAG->getTargetGlobalAddress(AM.GV, SDLoc(N), MVT::i256, AM.Disp,
                                          0 /*AM.SymbolFlags*/);
  else
    Disp = CurDAG->getTargetConstant(AM.Disp, SDLoc(N), MVT::i64);

  return true;
}

/// SelectStackAddr - returns true if it is able pattern match an addressing
/// mode for stack. It returns the operands which make up the maximal addressing
/// mode it can match by reference.
bool SyncVMDAGToDAGISel::SelectStackAddrCommon(SDValue N, SDValue &Base1,
                                               SDValue &Base2, SDValue &Disp,
                                               bool IsAdjusted) {
  SyncVMISelAddressMode AM;
  bool UseSP = false;

  if (MatchAddress(N, AM, true /* IsStackAddr */)) {
    AM = SyncVMISelAddressMode();
    if (MatchAddress(N, AM, false))
      return false;
  } else {
    UseSP = true;
  }

  // TODO: Hack (constant is used to designate immediate addressing mode),
  // redesign.
  if (!AM.Base.Reg.getNode())
    AM.Base.Reg = CurDAG->getTargetConstant(0, SDLoc(N), MVT::i256);

  if (UseSP) {
    Base1 = (AM.BaseType == SyncVMISelAddressMode::FrameIndexBase)
                ? CurDAG->getTargetFrameIndex(AM.Base.FrameIndex,
                                              getTargetLowering()->getPointerTy(
                                                  CurDAG->getDataLayout()))
                : Base1 = CurDAG->getTargetConstant(
                      0, SDLoc(N),
                      MVT::i256); // CurDAG->getRegister(SyncVM::SP, MVT::i256);
  } else {
    Base1 = CurDAG->getTargetConstant(0, SDLoc(N), MVT::i256);
  }
  Base2 = AM.Base.Reg;

  // 1(sp) is the index of the 1st element on the stack rather than 0(sp).
  if (AM.BaseType == SyncVMISelAddressMode::FrameIndexBase)
    AM.Disp = AM.Disp;

  if (AM.GV)
    Disp = CurDAG->getTargetGlobalAddress(AM.GV, SDLoc(N), MVT::i256, AM.Disp,
                                          0 /*AM.SymbolFlags*/);
  else
    Disp = CurDAG->getTargetConstant(AM.Disp, SDLoc(N), MVT::i64);

  return true;
}

bool SyncVMDAGToDAGISel::SelectStackAddr(SDValue N, SDValue &Base1,
                                         SDValue &Base2, SDValue &Disp) {
  return SelectStackAddrCommon(N, Base1, Base2, Disp, false);
}

bool SyncVMDAGToDAGISel::SelectAdjStackAddr(SDValue N, SDValue &Base1,
                                            SDValue &Base2, SDValue &Disp) {
  return SelectStackAddrCommon(N, Base1, Base2, Disp, true);
}

bool SyncVMDAGToDAGISel::SelectSTACKLOAD(SDValue N, SDValue &LOAD) {
  if (N->getOpcode() != ISD::LOAD) {
    return false;
  }
  auto opnd1 = N->getOperand(1);
  if (opnd1->getOpcode() == ISD::FrameIndex) {
    LOAD.setNode(opnd1.getNode());
    return true;
  }
  return false;
}

bool SyncVMDAGToDAGISel::SelectStackAddrReg(SDValue N, SDValue &LOAD) {
  SyncVMISelAddressMode AM;
  if (MatchAddress(N, AM, true /* IsStackAddr */)) {
    AM = SyncVMISelAddressMode();
    if (MatchAddress(N, AM, false))
      return false;
  }
  return false;
}

static bool isSmallConstant(SDValue Node) {
  if (!isa<ConstantSDNode>(Node)) {
    return false;
  }
  auto sdnode = cast<ConstantSDNode>(Node);
  APInt val = sdnode->getAPIntValue();
  // TODO: remove negative restriction
  if (!val.isSignedIntN(16) || val.isNegative()) {
    return false;
  }
  return true;
}

template<unsigned AS>
static bool isLoadFrom(SDValue Node) {
  if (Node->getOpcode() != ISD::LOAD) {
    return false;
  }

  LoadSDNode* SDNode = cast<LoadSDNode>(Node);
  if (SDNode->getAddressSpace() != AS) {
    return false;
  }

  return true;
}


bool SyncVMDAGToDAGISel::SelectStackDIV(StoreSDNode *store) {
  // encoding: isImm? isLoadFromStack? isLoadFromHeap? isLoadFromCode?
  DenseMap<uint8_t, std::pair<unsigned, bool>> Mapping = {
    {0b00000000, {SyncVM::DIVrrsr_s, false}},

    {0b10000000, {SyncVM::DIVirsr_s, false}},
    {0b01000000, {SyncVM::DIVsrsr_s, false}},
    {0b00010000, {SyncVM::DIVcrsr_s, false}},

    //{0b00001000, {SyncVM::DIVxrsr_s, true}},
    //{0b00000100, {SyncVM::DIVzrsr_s, true}},
    //{0b00000001, {SyncVM::DIVyrsr_s, true}},
  };
  return SelectStackOperation(store, ISD::UDIVREM, Mapping);
}

bool SyncVMDAGToDAGISel::SelectStackMUL(StoreSDNode *store) {
  // encoding: isImm? isLoadFromStack? isLoadFromHeap? isLoadFromCode?
  DenseMap<uint8_t, std::pair<unsigned, bool>> Mapping = {
    {0b00000000, {SyncVM::MULrrsr_s, false}},

    {0b10000000, {SyncVM::MULirsr_s, false}},
    {0b01000000, {SyncVM::MULsrsr_s, false}},
    {0b00010000, {SyncVM::MULcrsr_s, false}},

    //{0b00001000, {SyncVM::MULirsr_s, true}},
    //{0b00000100, {SyncVM::MULsrsr_s, true}},
    //{0b00000001, {SyncVM::MULcrsr_s, true}},
  };
  return SelectStackOperation(store, ISD::UMUL_LOHI, Mapping);
}

bool SyncVMDAGToDAGISel::SelectStackOperation(StoreSDNode *store,
                                              unsigned Operator,
                                              const MapType &Mapping) {
  SDValue value = store->getValue();
  if (value->getOpcode() != Operator) {
    return false;
  }

  // we have to make sure we are saving the dividend rather than the remainder.
  if (value.getResNo() != 0)  {
    return false;
  }

  SDValue chain = store->getChain();

  // depending on the operand types of UDIVREM, emit different DIV instructions
  SDValue opnd1 = value->getOperand(0);
  SDValue opnd2 = value->getOperand(1);


  auto getOpndEncoding = [](SDValue opnd) {
    uint8_t encoding =
        (isSmallConstant(opnd) ? 0b1000 : 0) |
        (isLoadFrom<SyncVMAS::AS_STACK>(opnd) ? 0b0100 : 0) |
        //(isLoadFrom<SyncVMAS::AS_HEAP>(opnd) ? 0b0010 : 0) |
        (isLoadFrom<SyncVMAS::AS_CODE>(opnd) ? 0b0001 : 0);
    return encoding;
  };

  uint8_t encoding =
    (getOpndEncoding(opnd1) << 4) | getOpndEncoding(opnd2);

  if (Mapping.count(encoding) == 0) {
    return false;
  }

  // cannot handle heap addressing
  if (isLoadFrom<SyncVMAS::AS_HEAP>(opnd1) || isLoadFrom<SyncVMAS::AS_HEAP>(opnd2)) {
    return false;
  }


  auto map = Mapping.lookup(encoding);
  auto opcode = map.first;
  bool flip = map.second;

  LLVM_DEBUG(dbgs() << "Converting to stack operator, flip: "<< flip << ".\n");

  SDLoc DL(store);

  auto push_opnd = [&](SmallVector<SDValue, 8> &ops, SDValue &opnd) {
    if (isSmallConstant(opnd)) {
      opnd = CurDAG->getTargetConstant(
          cast<ConstantSDNode>(opnd.getNode())->getAPIntValue().getSExtValue(),
          DL, MVT::i256);
      ops.push_back(opnd);
    } else if (isLoadFrom<SyncVMAS::AS_STACK>(opnd)) {
      SDValue Base1, Base2, Disp;
      LoadSDNode* load = cast<LoadSDNode>(opnd);
      bool successful =
          SelectStackAddr(load->getBasePtr(), Base1, Base2, Disp);
      assert(successful);
      ops.push_back(Base1);
      ops.push_back(Base2);
      ops.push_back(Disp);
    } else if (isLoadFrom<SyncVMAS::AS_CODE>(opnd)) {
      SDValue Base1, Disp;
      LoadSDNode* load = cast<LoadSDNode>(opnd);
      bool successful = SelectMemAddr(load->getBasePtr(), Base1, Disp);
      assert(successful);
      ops.push_back(Base1);
      ops.push_back(Disp);
    } else if (isLoadFrom<SyncVMAS::AS_HEAP>(opnd)) {
      llvm_unreachable("Does not support heap addressing.");
    } else {
      ops.push_back(opnd);
    }
  };

  SmallVector<SDValue, 8> ops_vec;
  if (flip) {
    push_opnd(ops_vec, opnd2);
    push_opnd(ops_vec, opnd1);
  } else {
    push_opnd(ops_vec, opnd1);
    push_opnd(ops_vec, opnd2);
  }

  // push stack address
  SDValue Base1, Base2, Disp;
  bool successful = SelectStackAddr(store->getBasePtr(), Base1, Base2, Disp);
  if (!successful) {
    return false;
  }
  ops_vec.push_back(Base1);
  ops_vec.push_back(Base2);
  ops_vec.push_back(Disp);

  // push cc NONE
  ops_vec.push_back(CurDAG->getTargetConstant(0, DL, MVT::i256));

  MachineRegisterInfo &RI = MF->getRegInfo();
  Register VReg = RI.createVirtualRegister(&SyncVM::GR256RegClass);

  auto ops = llvm::makeArrayRef(ops_vec);

  SDNode *ResNode = CurDAG->getMachineNode(opcode, DL, MVT::i256, ops);
  
  SDValue copyToReg = CurDAG->getCopyToReg(chain, DL, VReg, SDValue(ResNode, 0));
  ReplaceNode(store, copyToReg.getNode());

  // divert the remainder to the register
  ReplaceUses(value.getValue(1), CurDAG->getRegister(VReg, MVT::i256));
  return true;
}

void SyncVMDAGToDAGISel::Select(SDNode *Node) {
  SDLoc DL(Node);

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Few custom selection stuff.
  switch (Node->getOpcode()) {
  default:
    break;
  case ISD::Constant: {
    auto cn = cast<ConstantSDNode>(Node);
    auto val = cn->getAPIntValue();

    // if it is loading zero value, just select R0 to save its materialization
    // in another register
    if (val == 0) {
      auto R0 = CurDAG->getRegister(SyncVM::R0, MVT::i256);
      ReplaceNode(Node, R0.getNode());
      return;
    }

    // if it is small negative values, use SUB instruction to materialize it
    if (val.isNegative() && val.isSignedIntN(16)) {
      auto negated = -(val.getSExtValue());
      auto Negated_Val = CurDAG->getTargetConstant(negated, DL, MVT::i256);
      auto R0 = CurDAG->getRegister(SyncVM::R0, MVT::i256);
      auto SUB = CurDAG->getMachineNode(SyncVM::SUBxrr_p, DL, MVT::i256,
                                        SDValue(Negated_Val), R0);
      ReplaceNode(Node, SUB);
      return;
    }

    // if it cannot fit into the imm field of an instruction ... put it into
    // pool
    if (!val.isIntN(16) || val.isNegative()) {
      MVT PtrVT = getTargetLowering()->getPointerTy(CurDAG->getDataLayout());
      SDValue CP =
          CurDAG->getTargetConstantPool(cn->getConstantIntValue(), PtrVT);
      auto lc = CurDAG->getMachineNode(SyncVM::LOADCONST, DL, MVT::i256, CP);
      ReplaceNode(Node, lc);
      return;
    }
    break;
  }
  case ISD::FrameIndex: {
    assert(Node->getValueType(0) == MVT::i256);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i256);
    if (Node->hasOneUse()) {
      CurDAG->SelectNodeTo(Node, SyncVM::ADDframe, MVT::i256, TFI,
                           CurDAG->getTargetConstant(0, DL, MVT::i256));
      return;
    }
    ReplaceNode(Node, CurDAG->getMachineNode(
                          SyncVM::ADDframe, DL, MVT::i256, TFI,
                          CurDAG->getTargetConstant(0, DL, MVT::i256)));
    return;
  }
  case ISD::ZERO_EXTEND: {
    MVT outSize = Node->getSimpleValueType(0);
    MVT inSize = Node->getOperand(0)->getSimpleValueType(0);

    if (outSize == inSize) {
      // just ignore the selection of ZERO_EXTEND
      ReplaceNode(Node, Node->getOperand(0).getNode());
      return;
    }
    break;
  }
  case ISD::STORE: {
    // Match patterns like:
    // (store_stack (udivrem GR256:$src1, GR256:$src2):1, stackaddr:$dst1)
    if (ISD::isUNINDEXEDStore(Node)) {
      StoreSDNode* SDNode = cast<StoreSDNode>(Node);
      if (SDNode->getAddressSpace() == SyncVMAS::AS_STACK) {
        if (SelectStackDIV(SDNode)) {
          return;
        }
        if (SelectStackMUL(SDNode)) {
          return;
        }
      }
    }
    break;
  }
  }

  // Select the default instruction
  SelectCode(Node);
}

/// createSyncVMISelDag - This pass converts a legalized DAG into a
/// SyncVM-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createSyncVMISelDag(SyncVMTargetMachine &TM,
                                        CodeGenOpt::Level OptLevel) {
  return new SyncVMDAGToDAGISel(TM, OptLevel);
}
//
