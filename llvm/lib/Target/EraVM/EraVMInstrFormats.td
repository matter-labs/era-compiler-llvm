//===-- EraVMInstrFormats.td - EraVM Instruction Formats ---*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file describes the EraVM instruction formats in TableGen format.
//
//===----------------------------------------------------------------------===//

include "llvm/TableGen/SearchableTable.td"

//===----------------------------------------------------------------------===//
// Classes and defs used for relation maps.
//===----------------------------------------------------------------------===//

// The addressing mode can be categorized into operand addressing and destination addressing
// OperandAddrMode:
// RR : Reg Reg; SR : Stack Reg; CR : Code Reg; IR : Imm Reg;
class OperandAddrModeValue<bits<3> val> {
  bits<3> Value = val;
}
def OpndAddrNotSet : OperandAddrModeValue<0>;
def OpndRR         : OperandAddrModeValue<1>;
def OpndIR         : OperandAddrModeValue<2>;
def OpndSR         : OperandAddrModeValue<3>;
def OpndCR         : OperandAddrModeValue<4>;

// DestAddrMode:
class DestAddrModeValue<bits<3> val> {
  bits<3> Value = val;
}
def DestAddrNotSet : DestAddrModeValue<0>;
def ToReg          : DestAddrModeValue<1>;
def ToStack        : DestAddrModeValue<2>;
def ToRegReg       : DestAddrModeValue<3>;
def ToStackReg     : DestAddrModeValue<4>;

//===----------------------------------------------------------------------===//
// Instruction mapping tables

// Flag setting instructions
// Used to map: `_s` -> `_v`
// Flag setting instructions include: and, or, xor, add, sub, shl, shr, rol, ror, mul, div
class FlagSetting;

class mod_set_flags<bit silent> {
  bit Value = silent;
}

def PreserveFlags : mod_set_flags<0>;
def SetFlags : mod_set_flags<1>;

def getFlagSettingOpcode : InstrMapping {
  let FilterClass = "FlagSetting";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "DestAddrMode", "ReverseOperands"];
  let ColFields = ["Silent"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
}

def getNonFlagSettingOpcode : InstrMapping {
  let FilterClass = "FlagSetting";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "DestAddrMode", "ReverseOperands"];
  let ColFields = ["Silent"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

// Instructions that support swapping arguments
// This included non-commutative arithmetic ones: sub, shl, shr, rol, ror, div and
// pointer manipulation: ptr.add, ptr.sub, ptr.shrink, ptr.sub
class Swappable;

class mod_swap<bit swap> {
  bit Value = swap;
}

def NoSwap : mod_swap<0>;
def Swap : mod_swap<1>;

def withInsSwapped : InstrMapping {
  let FilterClass = "Swappable";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "DestAddrMode", "Silent"];
  let ColFields = ["ReverseOperands"];
  let KeyCol = ["0"];
  let ValueCols = [["1"]];
}

def withInsNotSwapped : InstrMapping {
  let FilterClass = "Swappable";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "DestAddrMode", "Silent"];
  let ColFields = ["ReverseOperands"];
  let KeyCol = ["1"];
  let ValueCols = [["0"]];
}

class AddrModeRel; // generic map of addressing mode of operands
class RetAddrModeRel; // generic map of addressing mode of results


def mapRRInputTo : InstrMapping {
  let FilterClass = "AddrModeRel";
  let RowFields = ["BaseOpcode", "DestAddrMode", "Silent"];
  let ColFields = ["OperandAM"];
  let KeyCol = ["0"];
  let ValueCols = [["0"], ["1"], ["2"], ["3"]];
}

def mapIRInputTo : InstrMapping {
  let FilterClass = "AddrModeRel";
  let RowFields = ["BaseOpcode", "DestAddrMode", "Silent"];
  let ColFields = ["OperandAM"];
  let KeyCol = ["1"];
  let ValueCols = [["0"], ["1"], ["2"], ["3"]];
}

def mapCRInputTo : InstrMapping {
  let FilterClass = "AddrModeRel";
  let RowFields = ["BaseOpcode", "DestAddrMode", "Silent"];
  let ColFields = ["OperandAM"];
  let KeyCol = ["2"];
  let ValueCols = [["0"], ["1"], ["2"], ["3"]];
}

def mapSRInputTo : InstrMapping {
  let FilterClass = "AddrModeRel";
  let RowFields = ["BaseOpcode", "DestAddrMode", "Silent"];
  let ColFields = ["OperandAM"];
  let KeyCol = ["3"];
  let ValueCols = [["0"], ["1"], ["2"], ["3"]];
}

def withStackResult : InstrMapping {
  let FilterClass = "RetAddrModeRel";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "Silent", "ReverseOperands"];
  let ColFields = ["ResultAM"];
  let KeyCol = ["0"];
  let ValueCols = [["3"]];
}

def withRegisterResult : InstrMapping {
  let FilterClass = "RetAddrModeRel";
  let RowFields = ["BaseOpcode", "OperandAddrMode", "Silent", "ReverseOperands"];
  let ColFields = ["ResultAM"];
  let KeyCol = ["3"];
  let ValueCols = [["0"]];
}

//===----------------------------------------------------------------------===//
// EraVM Opcodes
//===----------------------------------------------------------------------===//
class EraVMOpcode<string name, bits<11> opc> {
  string Name = name;
  bits<11> BaseOpcode = opc;
}
def EraVMOpcodesList : GenericTable {
  let FilterClass = "EraVMOpcode";
  let Fields = [
    "Name", "BaseOpcode"
  ];
  let PrimaryKey = [ "BaseOpcode" ];
  let PrimaryKeyName = "lookupEraVMOpcodeByValue";
}
def lookupEraVMOpcodeByName : SearchIndex {
  let Table = EraVMOpcodesList;
  let Key = [ "Name" ];
}

def OpInvalid : EraVMOpcode<"<invalid>", 0>;

def OpNoOp : EraVMOpcode<"nop", 1>;   // src dst ⇒ 1 + 4 × src + 1 × dst

def OpAdd  : EraVMOpcode<"add", 25>;  // src dst set_flags ⇒ 25 + 8 × src + 2 × dst + set_flags

def OpSub  : EraVMOpcode<"sub", 73>;  // src dst swap set_flags ⇒ 73 + 16 × src + 4 × dst + 2 × set_flags + swap

def OpMul  : EraVMOpcode<"mul", 169>; // src dst set_flags ⇒ 169 + 8 × src + 2 × dst + set_flags

def OpDiv  : EraVMOpcode<"div", 217>; // src dst swap set_flags ⇒ 217 + 16 × src + 4 × dst + 2 × set_flags + swap

def OpJump : EraVMOpcode<"jump",313>; // src ⇒ 313 + 1 × src

def OpXor  : EraVMOpcode<"xor", 319>; // src dst set_flags ⇒ 319 + 8 × src + 2 × dst + set_flags
def OpAnd  : EraVMOpcode<"and", 367>; // src dst set_flags ⇒ 367 + 8 × src + 2 × dst + set_flags
def OpOr   : EraVMOpcode<"or",  415>; // src dst set_flags ⇒ 415 + 8 × src + 2 × dst + set_flags

def OpShl  : EraVMOpcode<"shl", 463>; // src dst swap set_flags ⇒ 463 + 16 × src + 4 × dst + 2 × set_flags + swap
def OpShr  : EraVMOpcode<"shr", 559>; // src dst swap set_flags ⇒ 559 + 16 × src + 4 × dst + 2 × set_flags + swap
def OpRol  : EraVMOpcode<"rol", 655>; // src dst swap set_flags ⇒ 655 + 16 × src + 4 × dst + 2 × set_flags + swap
def OpRor  : EraVMOpcode<"ror", 751>; // src dst swap set_flags ⇒ 751 + 16 × src + 4 × dst + 2 × set_flags + swap

def OpPtrAdd    : EraVMOpcode<"ptr.add",    847>;  // src dst swap ⇒ 847 + 8 × src + 2 × dst + swap
def OpPtrSub    : EraVMOpcode<"ptr.sub",    895>;  // src dst swap ⇒ 895 + 8 × src + 2 × dst + swap
def OpPtrPack   : EraVMOpcode<"ptr.pack",   943>;  // src dst swap ⇒ 943 + 8 × src + 2 × dst + swap
def OpPtrShrink : EraVMOpcode<"ptr.shrink", 991>;  // src dst swap ⇒ 991 + 8 × src + 2 × dst + swap

def OpCall      : EraVMOpcode<"call",       1039>;
def OpContext   : EraVMOpcode<"context",    1040>; // op ⇒ 1040 + op
// aliased as log.sread
def OpSload     : EraVMOpcode<"sload",      1050>;
// aliased as log.swrite
def OpSstore    : EraVMOpcode<"sstore",     1051>;
// FIXME: Split those
// aliased as log.to_l1
def OpLogToL1   : EraVMOpcode<"to_l1",      1052>; // is_first ⇒ 1052 + is_first
// aliased as log.event
def OpLogEvent  : EraVMOpcode<"event",      1054>; // is_first ⇒ 1054 + is_first
// aliased as log.precompile
def OpLogPrecompile : EraVMOpcode<"precompile", 1056>;

def OpFarcall  : EraVMOpcode<"far_call",          1057>; // is_shard is_static ⇒ 1057 + 2 × is_static + is_shard
def OpDelegate : EraVMOpcode<"far_call.delegate", 1061>; // is_shard is_static ⇒ 1061 + 2 × is_static + is_shard
def OpMimic    : EraVMOpcode<"far_call.mimic",    1065>; // is_shard is_static ⇒ 1065 + 2 × is_static + is_shard

def OpRet      : EraVMOpcode<"ret.ok",    1069>; // to_label ⇒ 1069 + to_label
def OpRevert   : EraVMOpcode<"ret.revert", 1071>; // to_label ⇒ 1071 + to_label
def OpPanic    : EraVMOpcode<"ret.panic",  1073>; // to_label ⇒ 1073 + to_label

// aliased as uma.heap_read
def OpLoadHeap     : EraVMOpcode<"ld1", 1075>; // src inc ⇒ 1075 + 10 × src + inc
def OpLoadHeapInc  : EraVMOpcode<"ld1.inc", 1076>;

// aliased as uma.heap_write
def OpStoreHeap    : EraVMOpcode<"st1", 1077>; // src inc ⇒ 1077 + 10 × src + inc
def OpStoreHeapInc : EraVMOpcode<"st1.inc", 1078>;

// aliased as uma.aux_heap_read
def OpLoadAuxHeap  : EraVMOpcode<"ld2", 1079>; // src inc ⇒ 1079 + 10 × src + inc
def OpLoadAuxHeapInc  : EraVMOpcode<"ld2.inc", 1080>;
// aliased as uma.aux_heap_write
def OpStoreAuxHeap : EraVMOpcode<"st2", 1081>; // src inc ⇒ 1081 + 10 × src + inc
def OpStoreAuxHeapInc : EraVMOpcode<"st2.inc", 1082>;

// aliased as uma.fat_ptr_read
def OpLoadPtr      : EraVMOpcode<"ld",  1083>; // inc ⇒ 1083 + inc
def OpLoadPtrInc   : EraVMOpcode<"ld.inc",  1084>;

//===----------------------------------------------------------------------===//
// EraVM Instructions
//===----------------------------------------------------------------------===//
class SourceMode<bits<2> val> {
  bits<2> Value = val;
}

def SrcNone     : SourceMode<0>; // r0
def SrcReg      : SourceMode<0>; // r
def SrcCode     : SourceMode<1>; // m
def SrcStack    : SourceMode<2>; // m
def SrcImm      : SourceMode<3>; // i

class DestMode<bit val> {
  bit Value = val;
}

def DstNone     : DestMode<0>;   // r0
def DstReg      : DestMode<0>;   // r
def DstStack    : DestMode<1>;   // m

class RetFlags<bits<4> val> {
  bits<4> Value = val;
}

def RFNone           : RetFlags<0b0000>;
def RFErr            : RetFlags<0b0001>;
def RFPanic          : RetFlags<0b0010>;
def RFTransitRetData : RetFlags<0b0100>;

// Generic EraVM instruction
class EraVMInstruction : Instruction {
  let Namespace         = "EraVM";
  let DecoderNamespace  = "EraVM";
  let Pattern   = [];
}

// Pseudo instructions (do not have encoding information)
class Pseudo<dag outs, dag ins, list<dag> pattern>
  : EraVMInstruction {
  dag InOperandList  = ins;
  dag OutOperandList = outs;
  let Pattern        = pattern;
  let Size           = 8;

  let isCodeGenOnly = 1;
  let isPseudo = 1;
}

class Encoding {
  // 10:0  mach_opcode (11 bits)
  // 12:11 2 reserved bits
  // 15:13 predicate (3 bits)
  // 31:28, 27:24, 23:20, 19:16 reg_names (4 x 4 bits)
  // 63:48, 47:32 immediate u16 values (2 x 16 bits, big endian)

  field bits<64> Inst;
  field bits<64> SoftFail = 0;

  bits<16> Imm1 = 0;
  bits<16> Imm0 = 0;
  bits<4> Dst1 = 0b0000;
  bits<4> Dst0 = 0b0000;
  bits<4> Src1 = 0b0000;
  bits<4> Src0 = 0b0000;
  bits<3> Predicate;
  bits<11> Opcode;

  let Inst{63-48} = Imm1;
  let Inst{47-32} = Imm0;
  let Inst{31-28} = Dst1;
  let Inst{27-24} = Dst0;
  let Inst{23-20} = Src1;
  let Inst{19-16} = Src0;
  let Inst{15-13} = Predicate;
  let Inst{12-11} = 0;
  let Inst{10-0}  = Opcode;
}

let OperandType = "OPERAND_IMMEDIATE" in
def i256imm : Operand<i256>;

// Operand for printing out a condition code.
// TODO: We really do not need here full i256
def pred : PredicateOperand<i256, (ops i256imm), (ops (i256 0))> {
  let PrintMethod = "printCCOperand";
  let EncoderMethod = "getCCOpValue";
}

// Real instructions (have encoding)
class IForm <EraVMOpcode opcode,
             SourceMode as, DestMode ad,
             dag oops, dag inops,
             string opc, string asmstr,
             list<dag> pattern> : EraVMInstruction, Encoding
{
  bits<3> cc;

  dag InOperandList  = !con(inops, (ins pred:$cc));
  dag OutOperandList = oops;
  let AsmString      = !strconcat(opc, "${cc}", "\t", asmstr);
  let Pattern        = pattern;
  let Size           = 8;

  let Predicate = cc;
  // FIXME: This is not correct, we need to calculate real opcode out of the base one
  let Opcode = opcode.BaseOpcode;
}

class IRet<EraVMOpcode opcode, RetFlags flags, dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <opcode, SrcNone, DstNone, (outs), ins, opc, asmstr, pattern > {
}

class INop<dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <OpNoOp, SrcNone, DstNone, (outs), ins, opc, asmstr, pattern > {
}

class IJump<dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <OpJump, SrcNone, DstNone, (outs), ins, opc, asmstr, pattern> {
}

class IUMA<EraVMOpcode opcode, dag outs, dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <opcode, SrcNone, DstNone, outs, ins, opc, asmstr, pattern> {
}

class IContext<EraVMOpcode opcode, dag outs, dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <opcode, SrcNone, DstReg, outs, ins, opc, asmstr, pattern> {
}

class ILogR<EraVMOpcode opcode, DestMode ad, dag outs, dag ins,
            string opc, string asmstr, list<dag> pattern>
  : IForm <opcode, SrcReg, ad, outs, ins, opc, asmstr, pattern> {
}

class IBinary<EraVMOpcode opcode,
              SourceMode as, DestMode ad,
              mod_swap swap, mod_set_flags set_flags,
              dag outs, dag ins,
              string opc, string asmstr,
              list<dag> pattern>
  : IForm <opcode, as, ad, outs, ins, opc, asmstr, pattern > {
  string BaseOpcode;
  bit Silent = !eq(set_flags, PreserveFlags);
  bit ReverseOperands = !eq(swap, Swap);
  bits<3> OperandAddrMode = OpndAddrNotSet.Value;
  bits<3> DestAddrMode = DestAddrNotSet.Value;
  int OperandAM = 0;
  int ResultAM = 0;

  let AsmString = !strconcat(opc,
                             !if(!eq(swap, Swap), ".s", ""),
                             !if(!eq(set_flags, SetFlags), "!", ""),
                             "${cc}", "\t", asmstr);
  let Defs = !if(Silent, [], [Flags]);
  let mayLoad = !or(!eq(as, SrcCode), !eq(as, SrcStack));
  let mayStore = !eq(ad, DstStack);
}

class IBinaryR<EraVMOpcode opcode,
               SourceMode as,
               mod_swap swap_operands, mod_set_flags silent,
               dag outs, dag ins,
               string opc, string asmstr,
               list<dag> pattern>
  : IBinary <opcode, as, DstReg, swap_operands, silent, outs, ins, opc, asmstr, pattern > {
  bits<4> rd0;

  let DestAddrMode = ToReg.Value;
  let ResultAM = 0;

  let Dst0 = rd0;
}

class IBinaryS<EraVMOpcode opcode,
               SourceMode as,
               mod_swap swap_operands, mod_set_flags silent,
               dag outs, dag ins,
               string opc, string asmstr,
               list<dag> pattern>
  : IBinary <opcode, as, DstStack, swap_operands, silent, outs, ins, opc, asmstr, pattern > {
  // Encode stack operand into 20 bits as reg + imm offset
  bits<20> dst0;

  let DestAddrMode = ToStack.Value;
  let ResultAM = 3;

  let Dst0 = dst0{3-0};
  let Imm1 = dst0{19-4};
}

class Irr_r<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryR<opcode, SrcReg, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rs0;
  bits<4> rs1;

  let OperandAddrMode = OpndRR.Value;
  let OperandAM = 0;

  let Src0 = rs0;
  let Src1 = rs1;
}

class Irr_rr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Irr_r<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToRegReg.Value;
  let OperandAM = 0;

  let Dst1 = rd1;
}

class Iir_r<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryR<opcode, SrcImm, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rs1;
  bits<16> imm;

  let OperandAddrMode = OpndIR.Value;
  let OperandAM = 1;

  let Src1 = rs1;
  let Imm0 = imm;
}

class Iir_rr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Iir_r<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToRegReg.Value;
  let OperandAM = 1;

  let Dst1 = rd1;
}

class Imr_r<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryR<opcode, SrcCode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rs1;
  // FIXME: ensure we encode address mode properly
  bits<16> src0;

  let OperandAddrMode = OpndCR.Value;
  let OperandAM = 2;

  let Src1 = rs1;
  let Imm0 = src0;
}

class Isr_r<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryR<opcode, SrcStack, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<20> src0;
  bits<4> rs1;

  let OperandAddrMode = OpndSR.Value;
  let OperandAM = 3;

  let Src0 = src0{3-0};
  let Src1 = rs1;
  let Imm0 = src0{19-4};
}

class Imr_rr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Imr_r<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToRegReg.Value;
  let OperandAddrMode = OpndCR.Value;
  let OperandAM = 2;

  let Dst1 = rd1;
}

class Isr_rr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Isr_r<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToRegReg.Value;
  let OperandAM = 3;

  let Dst1 = rd1;
}

class Irr_s<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryS<opcode, SrcReg, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rs0;
  bits<4> rs1;

  let OperandAddrMode = OpndRR.Value;
  let OperandAM = 0;

  let Src0 = rs0;
  let Src1 = rs1;
}

class Irr_sr<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : Irr_s<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToStackReg.Value;
  let OperandAM = 0;

  let Dst1 = rd1;
}

class Iir_s<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryS<opcode, SrcImm, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<16> imm;
  bits<4> rs1;

  let OperandAddrMode = OpndIR.Value;
  let OperandAM = 1;

  let Imm0 = imm;
  let Src1 = rs1;
}

class Iir_sr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Iir_s<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToStackReg.Value;
  let OperandAM = 1;

  let Dst1 = rd1;
}

class Imr_s<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryS<opcode, SrcCode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rs1;
  // FIXME: ensure we encode address mode properly
  bits<16> src0;

  let OperandAddrMode = OpndCR.Value;
  let OperandAM = 2;

  let Src1 = rs1;
  let Imm0 = src0;
}

class Isr_s<EraVMOpcode opcode,
            mod_swap swap_operands, mod_set_flags silent,
            dag outs, dag ins,
            string opc, string asmstr,
            list<dag> pattern>
  : IBinaryS<opcode, SrcStack, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<20> src0;
  bits<4> rs1;

  let OperandAddrMode = OpndSR.Value;
  let OperandAM = 3;

  let Src0 = src0{3-0};
  let Src1 = rs1;
  let Imm0 = src0{19-4};
}

class Imr_sr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Imr_s<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToStackReg.Value;
  let OperandAM = 2;

  let Dst1 = rd1;
}

class Isr_sr<EraVMOpcode opcode,
             mod_swap swap_operands, mod_set_flags silent,
             dag outs, dag ins,
             string opc, string asmstr,
             list<dag> pattern>
  : Isr_s<opcode, swap_operands, silent, outs, ins, opc, asmstr, pattern> {
  bits<4> rd1;

  let DestAddrMode = ToStackReg.Value;
  let OperandAM = 3;

  let Dst1 = rd1;
}

class CallFlags<bits<4> val> {
  bits<4> Value = val;
}
def CFNormal         : CallFlags<0b0000>;
def CFDelegate       : CallFlags<0b0001>;
def CFMimic          : CallFlags<0b0010>;

class ICall<EraVMOpcode opcode, CallFlags flags, dag ins, string opc, string asmstr, list<dag> pattern>
  : IForm <opcode, SrcNone, DstNone, (outs), ins, opc, asmstr, pattern > {
}
