//===-- EraVMAddConditions.cpp - EraVM Add Conditions -----------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This pass changes _p instruction variants to _s.
//
//===----------------------------------------------------------------------===//

#include "EraVM.h"

#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/TargetInstrInfo.h"
#include "llvm/Support/Debug.h"

#include "EraVMSubtarget.h"

using namespace llvm;

#define DEBUG_TYPE "eravm-addcc"
#define ERAVM_ADD_CONDITIONALS_NAME "EraVM add conditionals"

namespace {

class EraVMAddConditions : public MachineFunctionPass {
public:
  static char ID;
  EraVMAddConditions() : MachineFunctionPass(ID) {}

  bool runOnMachineFunction(MachineFunction &MF) override;

  StringRef getPassName() const override { return ERAVM_ADD_CONDITIONALS_NAME; }

private:
  const TargetInstrInfo *TII{};
};

char EraVMAddConditions::ID = 0;

} // namespace

INITIALIZE_PASS(EraVMAddConditions, DEBUG_TYPE, ERAVM_ADD_CONDITIONALS_NAME,
                false, false)

bool EraVMAddConditions::runOnMachineFunction(MachineFunction &MF) {
  LLVM_DEBUG(
      dbgs() << "********** EraVM EXPAND PSEUDO INSTRUCTIONS **********\n"
             << "********** Function: " << MF.getName() << '\n');

  // TODO: The mapping should probably be generated by tablegen
  DenseMap<unsigned, unsigned> Pseudos{
      {EraVM::ADDrrr_p, EraVM::ADDrrr_s},
      {EraVM::ADDirr_p, EraVM::ADDirr_s},
      {EraVM::ADDcrr_p, EraVM::ADDcrr_s},
      {EraVM::ADDsrr_p, EraVM::ADDsrr_s},
      {EraVM::ADDrrs_p, EraVM::ADDrrs_s},
      {EraVM::ADDirs_p, EraVM::ADDirs_s},
      {EraVM::ADDcrs_p, EraVM::ADDcrs_s},
      {EraVM::ADDsrs_p, EraVM::ADDsrs_s},

      {EraVM::SUBrrr_p, EraVM::SUBrrr_s},
      {EraVM::SUBirr_p, EraVM::SUBirr_s},
      {EraVM::SUBcrr_p, EraVM::SUBcrr_s},
      {EraVM::SUBsrr_p, EraVM::SUBsrr_s},
      {EraVM::SUBrrs_p, EraVM::SUBrrs_s},
      {EraVM::SUBirs_p, EraVM::SUBirs_s},
      {EraVM::SUBcrs_p, EraVM::SUBcrs_s},
      {EraVM::SUBsrs_p, EraVM::SUBsrs_s},

      {EraVM::MULrrrr_p, EraVM::MULrrrr_s},
      {EraVM::MULirrr_p, EraVM::MULirrr_s},
      {EraVM::MULcrrr_p, EraVM::MULcrrr_s},
      {EraVM::MULsrrr_p, EraVM::MULsrrr_s},

      {EraVM::DIVrrrr_p, EraVM::DIVrrrr_s},
      {EraVM::DIVirrr_p, EraVM::DIVirrr_s},
      {EraVM::DIVcrrr_p, EraVM::DIVcrrr_s},
      {EraVM::DIVsrrr_p, EraVM::DIVsrrr_s},

      {EraVM::ANDrrr_p, EraVM::ANDrrr_s},
      {EraVM::ANDirr_p, EraVM::ANDirr_s},
      {EraVM::ANDcrr_p, EraVM::ANDcrr_s},
      {EraVM::ANDsrr_p, EraVM::ANDsrr_s},
      {EraVM::ANDrrs_p, EraVM::ANDrrs_s},
      {EraVM::ANDirs_p, EraVM::ANDirs_s},
      {EraVM::ANDcrs_p, EraVM::ANDcrs_s},
      {EraVM::ANDsrs_p, EraVM::ANDsrs_s},

      {EraVM::ORrrr_p, EraVM::ORrrr_s},
      {EraVM::ORirr_p, EraVM::ORirr_s},
      {EraVM::ORcrr_p, EraVM::ORcrr_s},
      {EraVM::ORsrr_p, EraVM::ORsrr_s},
      {EraVM::ORrrs_p, EraVM::ORrrs_s},
      {EraVM::ORirs_p, EraVM::ORirs_s},
      {EraVM::ORcrs_p, EraVM::ORcrs_s},
      {EraVM::ORsrs_p, EraVM::ORsrs_s},

      {EraVM::XORrrr_p, EraVM::XORrrr_s},
      {EraVM::XORirr_p, EraVM::XORirr_s},
      {EraVM::XORcrr_p, EraVM::XORcrr_s},
      {EraVM::XORsrr_p, EraVM::XORsrr_s},
      {EraVM::XORrrs_p, EraVM::XORrrs_s},
      {EraVM::XORirs_p, EraVM::XORirs_s},
      {EraVM::XORcrs_p, EraVM::XORcrs_s},
      {EraVM::XORsrs_p, EraVM::XORsrs_s},

      {EraVM::SHLrrr_p, EraVM::SHLrrr_s},
      {EraVM::SHLirr_p, EraVM::SHLirr_s},
      {EraVM::SHLcrr_p, EraVM::SHLcrr_s},
      {EraVM::SHLsrr_p, EraVM::SHLsrr_s},
      {EraVM::SHLrrs_p, EraVM::SHLrrs_s},
      {EraVM::SHLirs_p, EraVM::SHLirs_s},
      {EraVM::SHLcrs_p, EraVM::SHLcrs_s},
      {EraVM::SHLsrs_p, EraVM::SHLsrs_s},

      {EraVM::SHRrrr_p, EraVM::SHRrrr_s},
      {EraVM::SHRirr_p, EraVM::SHRirr_s},
      {EraVM::SHRcrr_p, EraVM::SHRcrr_s},
      {EraVM::SHRsrr_p, EraVM::SHRsrr_s},
      {EraVM::SHRrrs_p, EraVM::SHRrrs_s},
      {EraVM::SHRirs_p, EraVM::SHRirs_s},
      {EraVM::SHRcrs_p, EraVM::SHRcrs_s},
      {EraVM::SHRsrs_p, EraVM::SHRsrs_s},

      {EraVM::ROLrrr_p, EraVM::ROLrrr_s},
      {EraVM::ROLirr_p, EraVM::ROLirr_s},
      {EraVM::ROLcrr_p, EraVM::ROLcrr_s},
      {EraVM::ROLsrr_p, EraVM::ROLsrr_s},
      {EraVM::ROLrrs_p, EraVM::ROLrrs_s},
      {EraVM::ROLirs_p, EraVM::ROLirs_s},
      {EraVM::ROLcrs_p, EraVM::ROLcrs_s},
      {EraVM::ROLsrs_p, EraVM::ROLsrs_s},

      {EraVM::RORrrr_p, EraVM::RORrrr_s},
      {EraVM::RORirr_p, EraVM::RORirr_s},
      {EraVM::RORcrr_p, EraVM::RORcrr_s},
      {EraVM::RORsrr_p, EraVM::RORsrr_s},
      {EraVM::RORrrs_p, EraVM::RORrrs_s},
      {EraVM::RORirs_p, EraVM::RORirs_s},
      {EraVM::RORcrs_p, EraVM::RORcrs_s},
      {EraVM::RORsrs_p, EraVM::RORsrs_s},
  };

  bool Changed = false;
  TII = MF.getSubtarget<EraVMSubtarget>().getInstrInfo();
  assert(TII && "TargetInstrInfo must be a valid object");

  std::vector<MachineInstr *> PseudoInst;
  for (MachineBasicBlock &MBB : MF)
    for (MachineInstr &MI : MBB) {
      if (!Pseudos.count(MI.getOpcode()))
        continue;

      MI.setDesc(TII->get(Pseudos[MI.getOpcode()]));
      MI.addOperand(MachineOperand::CreateImm(0));
      Changed = true;
    }

  return Changed;
}

/// createEraVMAddConditionsPass - returns an instance of the pseudo
/// instruction expansion pass.
FunctionPass *llvm::createEraVMAddConditionsPass() {
  return new EraVMAddConditions();
}
