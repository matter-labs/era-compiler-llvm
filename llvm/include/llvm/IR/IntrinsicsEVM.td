//===---- IntrinsicsEVM.td - Defines EVM intrinsics --------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Defines all EVM intrinsics.
//
//===----------------------------------------------------------------------===//

// This must be in sync with the declaration of address spaces in EVM.h
def AS {
  int STACK = 0;
  int HEAP = 1;
  int CALL_DATA = 2;
  int RETURN_DATA = 3;
  int CODE = 4;
  int STORAGE = 5;
  int TSTORAGE = 6;
}

let TargetPrefix = "evm" in {

// Ethereum Virtual Machine (EVM) opcodes and corresponding intrinsics can be
// grouped by the runtime effects i.e., how their behavior or outputs are
// affected by state changes during a transaction:
//
//   - 'Readnone'
//     These do not read or write any persistent world-state once execution
//     begins. Their results depend only on provided inputs or fixed
//     environment data (constant during the transaction). They have no
//     lasting side effects and return the same result given the same inputs.
//
//   - 'Volatile (State-Dependent)'
//     These read data from the world state or execution environment that may
//     change within the same transaction (for example, due to prior storage
//     writes, value transfers, or external calls). Re-invoking them after a
//     state mutation can yield a different result. They themselves do not
//     permanently modify state. Such intrinsics have
//     'IntrInaccessibleMemOnly' attribute, or 'IntrReadMem,
//     IntrInaccessibleMemOnly' attributes to model dependency from the State.
//     NOTE: we assume (to be confirmed) that the heap is not part of the
//     State; therefore, it cannot be modified in a volatile manner.
//
//   - 'Side-Effecting (State-Changing)'
//     These opcodes cause persistent changes in world state - writing to
//     storage, emitting logs, creating or destroying contracts, or
//     transferring Ether. Their execution produces lasting side effects
//     recorded on-chain (storage updates, logs, new accounts, etc.). Such
//     intrinsics have no declared memory attributes, but their behavior is
//     refined through EVM alias analysis..

// Arithmetical operations.
def int_evm_div : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_sdiv : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                             [IntrNoMem, IntrWillReturn]>;

def int_evm_mod : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_smod : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                             [IntrNoMem, IntrWillReturn]>;

def int_evm_shl : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_shr : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_sar : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_addmod
    : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty, llvm_i256_ty],
                [IntrNoMem, IntrWillReturn]>;

def int_evm_mulmod
    : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty, llvm_i256_ty],
                [IntrNoMem, IntrWillReturn]>;

def int_evm_exp : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrWillReturn]>;

def int_evm_sha3
    : Intrinsic<[llvm_i256_ty], [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [IntrReadMem, IntrArgMemOnly, IntrNoCallback,
                 NoCapture<ArgIndex<0>>, IntrWillReturn]>;

def int_evm_signextend
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                            [IntrNoMem, IntrSpeculatable]>;

def int_evm_byte : Intrinsic<[llvm_i256_ty], [llvm_i256_ty, llvm_i256_ty],
                             [IntrNoMem, IntrWillReturn]>;

// Memory operations.
def int_evm_mstore8
    : Intrinsic<[], [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [IntrWriteMem, IntrArgMemOnly, NoCapture<ArgIndex<0>>,
                 IntrNoCallback, IntrWillReturn]>;

// Special getters that must not be relocated.
def int_evm_msize : Intrinsic<[llvm_i256_ty], [], [IntrWillReturn]>;

def int_evm_pc : Intrinsic<[llvm_i256_ty], [], [IntrWillReturn]>;

// TODO: #904: Set IntrInaccessibleMemOnly attribute to gas intrinsic.
// Currently, it is not set because benchmark numbers showed that it is not
// profitable to do that for heap address space. Revisit this decision once
// optimization for free ptr updates is implemented.
def int_evm_gas : Intrinsic<[llvm_i256_ty], [], [IntrWillReturn]>;

// Getting values from the context.
def int_evm_address
    : Intrinsic<[llvm_i256_ty], [], [IntrNoMem, IntrWillReturn]>;

def int_evm_origin
    : Intrinsic<[llvm_i256_ty], [],
                [IntrReadMem, IntrInaccessibleMemOnly, IntrWillReturn]>;

def int_evm_caller
    : Intrinsic<[llvm_i256_ty], [], [IntrNoMem, IntrWillReturn]>;

def int_evm_balance : Intrinsic<[llvm_i256_ty], [llvm_i256_ty],
                                [IntrReadMem, IntrInaccessibleMemOnly,
                                 IntrNoCallback, IntrWillReturn]>;

def int_evm_callvalue
    : Intrinsic<[llvm_i256_ty], [], [IntrNoMem, IntrWillReturn]>;

def int_evm_calldatasize
    : Intrinsic<[llvm_i256_ty], [], [IntrNoMem, IntrWillReturn]>;

def int_evm_calldataload
    : Intrinsic<[llvm_i256_ty], [LLVMQualPointerType<AS.CALL_DATA>],
                [IntrReadMem, IntrArgMemOnly, IntrNoCallback,
                 IntrWillReturn]>;

def int_evm_codesize : Intrinsic<[llvm_i256_ty], [],
                                 [IntrNoMem, IntrNoCallback, IntrWillReturn]>;

def int_evm_gasprice : Intrinsic<[llvm_i256_ty], [],
                                 [IntrReadMem, IntrInaccessibleMemOnly,
                                  IntrNoCallback, IntrWillReturn]>;

def int_evm_extcodesize : Intrinsic<[llvm_i256_ty], [llvm_i256_ty],
                                    [IntrReadMem, IntrInaccessibleMemOnly,
                                     IntrNoCallback, IntrWillReturn]>;

// TODO: #878. This intrinsicâ€™s declaration implies that it reads/writes to
// inaccessible memory (a limitation of the TableGen declaration format).
// Actually, it only reads from inaccessible memory. Its memory properties
// can be refined in the custom implementation of EVM AA.
def int_evm_extcodecopy
    : Intrinsic<[],
                [llvm_i256_ty, LLVMQualPointerType<AS.HEAP>,
                 LLVMQualPointerType<AS.CODE>, llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, WriteOnly<ArgIndex<1>>,
                 ReadOnly<ArgIndex<2>>, NoCapture<ArgIndex<1>>,
                 NoCapture<ArgIndex<2>>, IntrNoCallback, IntrWillReturn]>;

def int_evm_returndatasize : Intrinsic<[llvm_i256_ty], [],
                                       [IntrReadMem, IntrInaccessibleMemOnly,
                                        IntrNoCallback, IntrWillReturn]>;

def int_evm_extcodehash : Intrinsic<[llvm_i256_ty], [llvm_i256_ty],
                                    [IntrReadMem, IntrInaccessibleMemOnly,
                                     IntrNoCallback, IntrWillReturn]>;

def int_evm_blockhash : Intrinsic<[llvm_i256_ty], [llvm_i256_ty],
                                  [IntrReadMem, IntrInaccessibleMemOnly,
                                   IntrNoCallback, IntrWillReturn]>;

def int_evm_blobhash : Intrinsic<[llvm_i256_ty], [llvm_i256_ty],
                                 [IntrReadMem, IntrInaccessibleMemOnly,
                                  IntrNoCallback, IntrWillReturn]>;

def int_evm_coinbase : Intrinsic<[llvm_i256_ty], [],
                                 [IntrReadMem, IntrInaccessibleMemOnly,
                                  IntrNoCallback, IntrWillReturn]>;

def int_evm_timestamp : Intrinsic<[llvm_i256_ty], [],
                                  [IntrReadMem, IntrInaccessibleMemOnly,
                                   IntrNoCallback, IntrWillReturn]>;

def int_evm_number : Intrinsic<[llvm_i256_ty], [],
                               [IntrReadMem, IntrInaccessibleMemOnly,
                                IntrNoCallback, IntrWillReturn]>;

def int_evm_difficulty : Intrinsic<[llvm_i256_ty], [],
                                   [IntrReadMem, IntrInaccessibleMemOnly,
                                    IntrNoCallback, IntrWillReturn]>;

def int_evm_gaslimit : Intrinsic<[llvm_i256_ty], [],
                                 [IntrReadMem, IntrInaccessibleMemOnly,
                                  IntrNoCallback, IntrWillReturn]>;

def int_evm_chainid : Intrinsic<[llvm_i256_ty], [],
                                [IntrReadMem, IntrInaccessibleMemOnly,
                                 IntrNoCallback, IntrWillReturn]>;

def int_evm_selfbalance : Intrinsic<[llvm_i256_ty], [],
                                    [IntrReadMem, IntrInaccessibleMemOnly,
                                     IntrNoCallback, IntrWillReturn]>;

def int_evm_basefee : Intrinsic<[llvm_i256_ty], [],
                                [IntrReadMem, IntrInaccessibleMemOnly,
                                 IntrNoCallback, IntrWillReturn]>;

def int_evm_blobbasefee : Intrinsic<[llvm_i256_ty], [],
                                    [IntrReadMem, IntrInaccessibleMemOnly,
                                     IntrNoCallback, IntrWillReturn]>;

// Logging
def int_evm_log0
    : Intrinsic<[], [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 NoCapture<ArgIndex<0>>, IntrNoCallback, IntrWillReturn]>;

def int_evm_log1
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty, llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 NoCapture<ArgIndex<0>>, IntrNoCallback, IntrWillReturn]>;

def int_evm_log2
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty, llvm_i256_ty,
                 llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 NoCapture<ArgIndex<0>>, IntrNoCallback, IntrWillReturn]>;

def int_evm_log3
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty, llvm_i256_ty,
                 llvm_i256_ty, llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 NoCapture<ArgIndex<0>>, IntrNoCallback, IntrWillReturn]>;

def int_evm_log4
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty, llvm_i256_ty,
                 llvm_i256_ty, llvm_i256_ty, llvm_i256_ty],
                [IntrInaccessibleMemOrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 NoCapture<ArgIndex<0>>, IntrNoCallback, IntrWillReturn]>;

// System calls.
// The following intrinsics do not explicitly specify memory attributes,
// which by default implies arbitrary memory effects. Their actual
// (refined) memory effects are determined in EVMAAResult::getModRefInfo().
// Here, we only indicate which pointer arguments read from or write to
// heap memory, simplifying the implementation of
// EVMAAResult::getArgModRefInfo().
def int_evm_create
    : Intrinsic<[llvm_i256_ty],
                [llvm_i256_ty, LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [ReadOnly<ArgIndex<1>>, NoCapture<ArgIndex<1>>,
                 IntrNoCallback, IntrWillReturn]>;

def int_evm_call : Intrinsic<[llvm_i256_ty],
                             [llvm_i256_ty, llvm_i256_ty, llvm_i256_ty,
                              LLVMQualPointerType<AS.HEAP>, llvm_i256_ty,
                              LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                             [ReadOnly<ArgIndex<3>>, WriteOnly<ArgIndex<5>>,
                              NoCapture<ArgIndex<3>>, NoCapture<ArgIndex<5>>,
                              IntrNoCallback, IntrWillReturn]>;

def int_evm_callcode
    : Intrinsic<[llvm_i256_ty],
                [llvm_i256_ty, llvm_i256_ty, llvm_i256_ty,
                 LLVMQualPointerType<AS.HEAP>, llvm_i256_ty,
                 LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [ReadOnly<ArgIndex<3>>, WriteOnly<ArgIndex<5>>,
                 NoCapture<ArgIndex<3>>, NoCapture<ArgIndex<5>>,
                 IntrNoCallback, IntrWillReturn]>;

def int_evm_delegatecall
    : Intrinsic<[llvm_i256_ty],
                [llvm_i256_ty, llvm_i256_ty, LLVMQualPointerType<AS.HEAP>,
                 llvm_i256_ty, LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [ReadOnly<ArgIndex<2>>, WriteOnly<ArgIndex<4>>,
                 NoCapture<ArgIndex<2>>, NoCapture<ArgIndex<4>>,
                 IntrNoCallback, IntrWillReturn]>;

def int_evm_create2
    : Intrinsic<[llvm_i256_ty],
                [llvm_i256_ty, LLVMQualPointerType<AS.HEAP>, llvm_i256_ty,
                 llvm_i256_ty],
                [ReadOnly<ArgIndex<1>>, NoCapture<ArgIndex<1>>,
                 IntrNoCallback, IntrWillReturn]>;

def int_evm_staticcall
    : Intrinsic<[llvm_i256_ty],
                [llvm_i256_ty, llvm_i256_ty, LLVMQualPointerType<AS.HEAP>,
                 llvm_i256_ty, LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [ReadOnly<ArgIndex<2>>, WriteOnly<ArgIndex<4>>,
                 NoCapture<ArgIndex<2>>, NoCapture<ArgIndex<4>>,
                 IntrNoCallback, IntrWillReturn]>;

def int_evm_selfdestruct : Intrinsic<[], [llvm_i256_ty], []>;

def int_evm_stop : Intrinsic<[], [], [IntrNoReturn]>;

def int_evm_invalid : Intrinsic<[], [], [IntrNoReturn]>;

// Return with error.
// 'Return' and 'Revert' exhibit slightly different behaviors.
// In EVM AA, 'Return' is treated as aliasing with the Storage/Transient
// address spaces, whereas 'Revert' is not. This distinction allows the
// elimination of stores to Storage that occur before a 'Revert'.
def int_evm_return
    : Intrinsic<[], [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [IntrReadMem, ReadOnly<ArgIndex<0>>, IntrNoReturn]>;

def int_evm_revert
    : Intrinsic<[], [LLVMQualPointerType<AS.HEAP>, llvm_i256_ty],
                [IntrReadMem, IntrArgMemOnly, ReadOnly<ArgIndex<0>>,
                 IntrNoReturn]>;

def int_evm_memmoveas1as1
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, LLVMQualPointerType<AS.HEAP>,
                 llvm_i256_ty, llvm_i1_ty],
                [IntrArgMemOnly, IntrWillReturn, IntrNoFree, IntrNoCallback,
                 NoCapture<ArgIndex<0>>, NoCapture<ArgIndex<1>>,
                 WriteOnly<ArgIndex<0>>, ReadOnly<ArgIndex<1>>,
                 ImmArg<ArgIndex<3>>]>;

def int_evm_memcpyas1as2
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>,
                 LLVMQualPointerType<AS.CALL_DATA>, llvm_i256_ty, llvm_i1_ty],
                [IntrArgMemOnly, IntrWillReturn, IntrNoFree, IntrNoCallback,
                 NoCapture<ArgIndex<0>>, NoCapture<ArgIndex<1>>,
                 NoAlias<ArgIndex<0>>, NoAlias<ArgIndex<1>>,
                 WriteOnly<ArgIndex<0>>, ReadOnly<ArgIndex<1>>,
                 ImmArg<ArgIndex<3>>]>;

def int_evm_memcpyas1as3
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>,
                 LLVMQualPointerType<AS.RETURN_DATA>, llvm_i256_ty,
                 llvm_i1_ty],
                [IntrArgMemOnly, IntrWillReturn, IntrNoFree, IntrNoCallback,
                 NoCapture<ArgIndex<0>>, NoCapture<ArgIndex<1>>,
                 NoAlias<ArgIndex<0>>, NoAlias<ArgIndex<1>>,
                 WriteOnly<ArgIndex<0>>, ReadOnly<ArgIndex<1>>,
                 ImmArg<ArgIndex<3>>]>;

def int_evm_memcpyas1as4
    : Intrinsic<[],
                [LLVMQualPointerType<AS.HEAP>, LLVMQualPointerType<AS.CODE>,
                 llvm_i256_ty, llvm_i1_ty],
                [IntrArgMemOnly, IntrWillReturn, IntrNoFree, IntrNoCallback,
                 NoCapture<ArgIndex<0>>, NoCapture<ArgIndex<1>>,
                 NoAlias<ArgIndex<0>>, NoAlias<ArgIndex<1>>,
                 WriteOnly<ArgIndex<0>>, ReadOnly<ArgIndex<1>>,
                 ImmArg<ArgIndex<3>>]>;

// The following intrinsics are used for linking purposes.

// Returns a code size of the Yul object with the name
// passed in the metadata.
def int_evm_datasize
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [llvm_metadata_ty],
                            [IntrNoMem, IntrWillReturn]>;

// Returns a code offset of the Yul object with the name
// passed in the metadata.
def int_evm_dataoffset
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [llvm_metadata_ty],
                            [IntrNoMem, IntrWillReturn]>;

// Linking of libraries.

// Inserts a library address placeholder to be replaced with
// a library address at linkage time.
def int_evm_linkersymbol
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [llvm_metadata_ty],
                            [IntrNoMem, IntrWillReturn]>;

// The intrinsic call should not be optimized out, even though
// its result is not used. For this, IntrInaccessibleMemOnly is
// used.
def int_evm_pushdeployaddress
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [],
                            [IntrInaccessibleMemOnly, IntrWillReturn,
                             IntrNoDuplicate]>;

// Immutables support.

// Loads immutable value. Should be used only in runtime code.
def int_evm_loadimmutable
    : DefaultAttrsIntrinsic<[llvm_i256_ty], [llvm_metadata_ty],
                            [IntrNoMem, IntrWillReturn]>;
} // TargetPrefix = "evm"
